### 动态代理

在java中，接口(interface)并不能被实例化，所有`interface`类型的变量总是通过某个实例向上转型并赋值给接口类型变量的

通常我们要调用接口，需要写一个实现接口的类，并实现接口中定义的方法

然而，通过动态代理，我们可以不创建一个实现类，而在运行期创建interface的实例

+ 静态调用接口

  ```java
  public interface Hello{
      void talk(String name);
  }
  
  
  public class helloworld implements Hello {
      public  void talk(String name){
          System.out.println("talk to " + name);
      }
  }
       public static  void main(String[] args){
           Hello hello = new helloworld();
           hello.talk("uu2fu3o");
       }
  ```

  这是我们静态调用一个接口的实现

+ 动态代理调用

  ```java
       public static void main(String[] args){
              InvocationHandler handler = new InvocationHandler() { //匿名类的写法，负责实现接口的方法调用
                  @Override
                  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { //重写invoke方法
                      System.out.println(method);
                      if(method.getName().equals("talk")){
                          System.out.println("talk to " + args[0]);
                      }
                      return null;
                  }
              };
              Hello hello =(Hello) Proxy.newProxyInstance( //通过Proxy.newProxyInstance()创建interface实例
                      Hello.class.getClassLoader(), // 传入ClassLoader
                      new Class[] { Hello.class }, // 传入要实现的接口
                      handler); // 传入处理调用方法的InvocationHandler
           hello.talk("uu2fu3o");
  
       }
  }
  ```
  
  动态代理是通过`Proxy`创建代理对象，然后将接口方法“代理”给`InvocationHandler`完成的。

### 使用java.lang.reflect.Proxy动态创建类对象

java.lang.reflect.Proxy类中有像ClassLoader和Unsafe中的defineClassXXX的native方法，名为defineClass0,通过这个方法，我们可以调用java.lang.reflect.Proxy向JVM中创建一个类对象

为此我们需要反射获取defineClass0方法

**动态代理生成出来的类有如下技术细节和特性：**

1. 动态代理的必须是接口类，通过`动态生成一个接口实现类`来代理接口的方法调用(`反射机制`)。
2. 动态代理类会由`java.lang.reflect.Proxy.ProxyClassFactory`创建。
3. `ProxyClassFactory`会调用`sun.misc.ProxyGenerator`类生成该类的字节码，并调用`java.lang.reflect.Proxy.defineClass0()`方法将该类注册到`JVM`。
4. 该类继承于`java.lang.reflect.Proxy`并实现了需要被代理的接口类，因为`java.lang.reflect.Proxy`类实现了`java.io.Serializable`接口，所以被代理的类支持`序列化/反序列化`。
5. 该类实现了代理接口类(示例中的接口类是`com.anbai.sec.proxy.FileSystem`)，会通过`ProxyGenerator`动态生成接口类(`FileSystem`)的所有方法，
6. 该类因为实现了代理的接口类，所以当前类是代理的接口类的实例(`proxyInstance instanceof FileSystem`为`true`)，但不是代理接口类的实现类的实例(`proxyInstance instanceof UnixFileSystem`为`false`)。
7. 该类方法中包含了被代理的接口类的所有方法，通过调用动态代理处理类(`InvocationHandler`)的`invoke`方法获取方法执行结果。
8. 该类代理的方式重写了`java.lang.Object`类的`toString`、`hashCode`、`equals`方法。
9. 如果动过动态代理生成了多个动态代理类，新生成的类名中的`0`会自增，如`com.sun.proxy.$Proxy0/$Proxy1/$Proxy2`。