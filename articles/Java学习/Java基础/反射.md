通过反射获取到任何类的成员方法(`Methods`)、成员变量(`Fields`)、构造方法(`Constructors`)等信息

动态创建Java类实例、调用任意的类方法、修改任意的类成员变量值等

### 获取Class对象

三种方式

name.class

Class.forName

classLoader.loadClass

**只有在Class.forname在获取类对象时会加载静态代码块和调用构造方法**

### 通过反射获取实例化对象

```java
Reflecttest.java

package javalearn.src;
import java.util.Arrays;

public class Reflecttest{
    public static  void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        String className  = "javalearn.src.test";
        Class class1 = Class.forName(className);
        Object obj = class1.newInstance();
        System.out.println(obj.toString());
    }
}
```

```java
test.java

package javalearn.src;
 public class test {
       public String toString(){
           return  "uu2fu3o";
       }
}
```

现在将test构造方法设置为private,会发现

![image-20240302165329897](https://raw.githubusercontent.com/uu2fu3o/blog-picture/master/cloud/image-20240302165329897.png)

我们需要通过反射去修改方法的访问权限`constructor.setAccessible(true)`。

```java
package javalearn.src;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.Arrays;

public class Reflecttest{
    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {
        String className  = "javalearn.src.test";
//        Class class1 = Class.forName(className);
//        Class  runtimeClass2 = javalearn.src.test.class;
//        Class  runtimeClass3 = ClassLoader.getSystemClassLoader().loadClass(className);
        Class  clazz = Class.forName(className);
        //获取构造方法
        Constructor constructor = clazz.getDeclaredConstructor();
        constructor.setAccessible(true);
        //创建类实例
        Object obj = constructor.newInstance();
        System.out.println(obj.toString());
    }
}
```

### 反射调用类方法

获取当前类所有成员方法

```
Method[] methods = clazz.getDeclaredMethods()
```

获取当前类指定成员方法

```java
Method method = clazz.getDeclaredMethod("方法名");
Method method = clazz.getDeclaredMethod("方法名", 参数类型如String.class，多个参数用","号隔开);
```

`getMethod`和`getDeclaredMethod`都能够获取到类成员方法，区别在于`getMethod`只能获取到`当前类和父类`的所有有权限的方法(如：`public`)，而`getDeclaredMethod`能获取到当前类的所有成员方法(不包含父类)。

+ 调用类方法

  ```
  method.invoke(方法实例对象，方法参数值) //多个参数用,隔开
  ```

```
        Object obj = constructor.newInstance();
        //获取方法
        Method method = clazz.getDeclaredMethod("exec");
        //调用方法
        //如果这个方法是私有的
        //method.setAccessible(true);设置为true即可调用
        method.invoke(obj);
        
```

### 反射调用成员变量

+ 获取当前类所有成员变量

  ```
  Field fields = clazz.getDeclaredFields();
  ```

+ 获取当前类指定成员变量

  ```
  Field field  = clazz.getDeclaredField("变量名");
  ```

`getField`和`getDeclaredField`的区别同`getMethod`和`getDeclaredMethod`。

+ 获取成员变量值

  ```
  Object obj = field.get(类实例对象);
  ```

+ 修改成员变量值

  ```
  field.set(类实例对象, 修改后的值);
  ```

**private和final都无法直接修改，需要设置权限**

```Java
		Field modifiers = clazz.getDeclaredField("modifiers");//获取modifiers变量
        modifiers.setAccessible(true);
        modifiers.set(obj,"changed");//修改成员变量的值
        Object value = modifiers.get(obj);
        System.out.println(value);
```

### 通过allocateInstance无视构造方法创建类实例

因为某种原因我们不能直接通过反射的方式去创建`UnSafeTest`类实例，那么这个时候使用`Unsafe`的`allocateInstance`方法就可以绕过这个限制

```
// 使用Unsafe创建UnSafeTest类实例
UnSafeTest test = (UnSafeTest) unsafe1.allocateInstance(UnSafeTest.class);
```

### defineClass直接调用JVM创建类对象

`Unsafe`提供了一个通过传入类名、类字节码的方式就可以定义类的`defineClass`方法

```
public native Class defineClass(String var1, byte[] var2, int var3, int var4);

public native Class<?> defineClass(String var1, byte[] var2, int var3, int var4, ClassLoader var5, ProtectionDomain var6);
```

仅适用于java8之前

