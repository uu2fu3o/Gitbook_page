## 序列化和反序列化

Java对象序列化指的是`将一个Java类实例序列化成字节数组`，用于存储对象实例化信息：类成员变量和属性值。 Java反序列化可以`将序列化后的二进制数组转换为对应的Java类实例`。

在Java中实现对象反序列化非常简单，实现`java.io.Serializable(内部序列化)`或`java.io.Externalizable(外部序列化)`接口即可被序列化，其中`java.io.Externalizable`接口只是实现了`java.io.Serializable`接口。

> 事实上java.io.Externalizable不仅是实现了Serializable的接口，它增加了两个方法：writeExternal和readExternal，需要自己重新覆写，可以自定义序列化和反序列化的流程

反序列化类对象时有如下限制：

1. 被反序列化的类必须存在。
2. `serialVersionUID`值必须一致。

>  serialVersionUID是辅助序列化和反序列化的唯一标识，用于判断类是否一致

**反序列化类对象是不会调用该类构造方法**

sun.reflect.ReflectionFactory.newConstructorForSerialization`创建了一个反序列化专用的`Constructor(反射构造方法对象),这个构造器可以绕过构造方法创建类实例

> sun.misc.Unsafe使用`allocateInstance`方法也可以实现绕过构造方法创建类实例

看下代码

```java
package javalearn.src;

import sun.reflect.ReflectionFactory;

import java.lang.reflect.Constructor;

public class SerializableTest {
    public static  void main(String[] args){
        try {
            ReflectionFactory factory = ReflectionFactory.getReflectionFactory();
            //通过反序列化的方式获取目标类的构造方法
            Constructor constructor = factory.newConstructorForSerialization(
                    test.class,Object.class.getConstructor()
            );
            System.out.println(constructor.newInstance());
        }catch(Exception e){
            e.printStackTrace();
        }
    }
}
```

```java
public class test {
     public test() { //定义的构造方法
         System.out.println("这里是构造方法");
     }

     //     public test(){System.out.println("no");}
     //构造方法设置为私有
    public String toString() {
         return "uu2fu3o";
     }

     private void exec() {
         System.out.println("this is a method");
     }

     private String modifiers = "uu2fu3o";

     static {
         System.out.println("yes");
     }

 }
```

> 如果这里我们没有设置test类的toString方法，会输出对象名称
>
> 这里，实际上是使用Java内部类`sun.reflect.ReflectionFactory`的`newConstructorForSerialization`方法来反射得到一个构造方法，并通过这个构造方法来创建一个新的对象。

##  ObjectInputStream、ObjectOutputStream

`java.io.ObjectOutputStream`类最核心的方法是`writeObject`方法，即序列化类对象。

`java.io.ObjectInputStream`类最核心的功能是`readObject`方法，即反序列化类对象。

看代码

+ SerializableTest.java

  ```java
  package javalearn.src;
  
  
  import java.io.*;
  import java.util.Arrays;
  
  public class SerializableTest {
      public static void main(String[] args) {
          ByteArrayOutputStream baos = new ByteArrayOutputStream();
          //创建一个字节数组缓冲区，用来将之后序列化后的字节流写入到baos这个字节流中
  
          try {
              // 创建DeserializationTest类，并类设置属性值
              DeserializationTest t = new DeserializationTest();
              t.setUsername("uu2fu3o");
              t.setEmail("uu2fu3o@admin.com");
  
              // 创建Java对象序列化输出流对象
              ObjectOutputStream out = new ObjectOutputStream(baos);
  
              // 序列化DeserializationTest类
              out.writeObject(t); 
              out.flush();
              out.close();
  
              // 打印DeserializationTest类序列化以后的字节数组，我们可以将其存储到文件中或者通过Socket发送到远程服务地址
              System.out.println("DeserializationTest类序列化后的字节数组:" + Arrays.toString(baos.toByteArray()));
  
              // 利用DeserializationTest类生成的二进制数组创建二进制输入流对象用于反序列化操作
              ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
  
              // 通过反序列化输入流(bais),创建Java对象输入流(ObjectInputStream)对象
              ObjectInputStream in = new ObjectInputStream(bais);
  
              // 反序列化输入流数据为DeserializationTest对象
              DeserializationTest test = (DeserializationTest) in.readObject();
              System.out.println("用户名:" + test.getUsername() + ",邮箱:" + test.getEmail());
  
              // 关闭ObjectInputStream输入流
              in.close();
          } catch (IOException | ClassNotFoundException e) {
              e.printStackTrace();
          }
      }
  }
  
  ```

+ DeserializationTest.java

  ```Java
  package javalearn.src;
  
  
  import java.io.Serializable;
  
  public class DeserializationTest implements Serializable {
      public String username;
  
      public String email;
      public void setUsername(String username){
          this.username = username;
      }
      public void setEmail(String email){
          this.email = email;
      }
      public String getUsername(){
          return this.username;
      }
  
      public String getEmail(){
          return this.email;
      }
  
  }
  ```

输出结果

![image-20240306203353097](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240306203353097.png)

> 为什么要被序列化的数字需要继承Serializable接口，Serializable接口虽然为空，但是却起到标识类是否能被序列化。这与之前提到的serialVersionUID唯一标识有关
>
> ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());为什么要进行toByteArray()操作？
>
> baos为一个字节数组缓冲区，ByteArrayInputStream接受一个字节数组作为参数，因此需要进行转换操作

> 我们可以通过在待**序列化或反序列化的类中定义`readObject`和`writeObject`方法，来实现自定义的序列化和反序列化操作**，当然前提是，被序列化的类必须有此方法，并且方法的修饰符必须是`private`。
