## 域用户

### 查询域用户

+ ·通过SAMR查询

  samr是一个RPC接口，平时使用的`net user /domain`就是使用该接口进行查询的

  ![image-20231123134059907](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231123134059907.png)

  impacket中有专门调用该接口进行域用户查询的工具，前提是满足域用户查询的条件

  ![image-20231123134450836](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231123134450836.png)

+ 通过ldap进行查询

  域用户存储于活动目录数据库里面，对其他用户可见。可以通过Ldap 去查询。

  ```
  (&(objectCategory=person)(objectClass=user))
  ```

  ![image-20231123135029874](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231123135029874.png)

### 域用户部分属性介绍

+ sn 

  域用户的姓

  ![image-20231123140806524](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231123140806524.png)

+ giveName

  域用户的名，没有返回说明没有设置

  ![image-20231123140900505](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231123140900505.png)

+ displayName

  域用户的展示名，不用于登录，虽然跟域用户名往往一样。但是这个不是直接用于登陆的我们登陆用的账号。

  ![image-20231123140951314](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231123140951314.png)

**域用户登录格式**

+ UserPrincipalName（UPN）一般的格式是`用户名@域名`

  ![image-20231123141647155](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231123141647155.png)

+ 域名\sAMAccountName

  域名可以是netbios名，也可以是dns 名

  ![image-20231123141759269](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231123141759269.png)

**用户相关的一些时间**

+ whenCreated

+ pwdLastSet

+ Lastlogon

分别指代了用户的创建时间，密码设置时间，上次登录时间

利用adfind的-tdcs参数自动对时间进行转化

值得注意的是**Lastlogon**这个属性值在不同的域控制器上是不会同步的。所以要查询一个用户的最后登录时间，得指定不同的域控制器来查询。

![image-20231123142424684](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231123142424684.png)

![image-20231123142456952](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231123142456952.png)

可见，在不同的域控制器上，Lastlogon参数是没有同步的

**userAccountControl**

这是一个位属性，我们可以通过位查询来检索该属性，这个属性非常重要

例如我们想查询设置了约束委派的用户

![image-20231123142724525](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231123142724525.png)

![image-20231123142913844](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231123142913844.png)

这个查表用对应的十进制值进行·过滤即可

## 机器用户

默认情况底下，加入域的机器默认在`CN=Computer`这个容器里面，域控默认在`Domain Controllers`这个OU里面。有些域内会通过`redircmp`进行修改

![image-20231123143507795](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231123143507795.png)

### 机器用户跟system 用户的关系

protocol假设了一种场景，如果我们拿到一台域内机器，但没有域用户该怎么办，可以从AD来看

我们知道域用户是User类的实例

![image-20231123144204340](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231123144204340.png)

机器是computer的实例

![image-20231123144249316](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231123144249316.png)

computer是user的子类

![image-20231123144325495](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231123144325495.png)

子类会继承父类的所有属性，因此从AD来看，域用户拥有的权限机器用户都该有。

其本地用户SYSTEM就对应于域内的机器用户，在域内的用户名就是机器名+$，例如这里的PC

![image-20231123144518394](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231123144518394.png)

对应的就是PC$

将当前用户提到system(非管理员需要配合提权漏洞，管理员组的非administrators需要bypassuac，administrator提到system。这个网上有很多方法，psexec，mimikatz等等)。就可以在域内充当机器用户了。

### 查找域内的所有机器

通过`objectclass=Computer`或者`objectcategory=Computer`查找域内的所有机器

![image-20231123145608040](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231123145608040.png)

adfind对查询域机器提供了一些方便的方法，这里用protocol截出来的图

![img](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/t011f6d61516131b3a2.png)

![image-20231123145932492](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231123145932492.png)

通过查询OU=Domain Controllers来查询域控机器

![image-20231123150135414](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231123150135414.png)

同样adfind对查询域控也提供了简便操作

![img2](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/t01a86d45d667736a9d.png)

![image-20231123150302794](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231123150302794.png)

## 域用户账户与机器用户的对应关系

### 域用户默认能登录域内的任何一台普通机器

在域内的一台机器默认允许Users组进行登录

![image-20231123151317983](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231123151317983.png)

Users组中默认包含了Domain Users

![image-20231123152036769](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231123152036769.png)

而域内用户默认都在Domain Users组里面。因此默认情况下域用户可以登录域内任何一台机器。

如何限制这种登录？

可以从用户和机器两边做限制，例如限制用户的登录

![image-20231123153012266](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231123153012266.png)

在机器这边做限制

一般都会把常登陆这台机器的域用户加入到Administrators组里面。不允许User组里面用户本地登录。把下图的Users删除掉。这样登陆这台机器的域用户，因为在Administrators组里面，也可以登录。而其他域用户也不能登录。

![image-20231123153121821](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231123153121821.png)

### 查看域用户能够登录的主机

限制了域用户只能登录到某台主机之后，在LDAP里面，会设置一个字段，userWorkStation。这个字段保存了这个域用户只能登录到某台机器。而这个字段对于域内任何用户都是可读的，我们可以通过读域用户的userWorkStation来查看域用户限制登录到那一台机子。那个用户也就能够登录那台机子。

![image-20231123164251393](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231123164251393.png)

### 查看域用户正在登陆的主机

+ 检查远程机器注册表项里`HKEY_USERS`来查询谁正在登陆机

  在当前机器上远程登录注册表来查看谁在登录域内其他机器

  ![image-20231123164228533](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231123164228533.png)

  

远程查看注册表项这个操作可以通过API实现，我们可以遍历域内所有机器，查询机器正在登陆的用户。

值得注意的有:

-  默认PC机器，是没有开启注册表远程连接的。Server 机器，默认开启远程连接。

-  域内任何用户，即使配置了，不能本地登录域内机器A，但是只要域内机器A开启远程注册表连接，我们就可以连接上机器A的注册表，从而枚举正在登陆的用户

  

+ 利用 `NetSessionEnum` 来寻找登陆的网络会话。

  一个win32 API，如下

  ```c++
  NET_API_STATUS NET_API_FUNCTION NetSessionEnum(
    LMSTR   servername,
    LMSTR   UncClientName,
    LMSTR   username,
    DWORD   level,
    LPBYTE  *bufptr,
    DWORD   prefmaxlen,
    LPDWORD entriesread,
    LPDWORD totalentries,
    LPDWORD resume_handle
  );
  ```

  该函数第一个参数servername为指向一个字符串的指针，该字符串指定要在其上执行函数的远程服务器的 DNS 或 NetBIOS 名称。如果此参数为 NULL，则使用本地计算机。当该参数指向一个远程主机A，会去调用远程机器A的RPC。然后返回其他用户在访问机器A的网络资源（例如文件共享）时所创建的网络会话，可以看到这个用户来自何处。

  我们可以使用netsess来完成这项工作

  ![image-20231123175819502](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231123175819502.png)

注意：

指定了servername 为机器A，并不能查询谁谁登陆了机器A，但是可以看到访问机器A的网络资源（例如文件共享）时所创建的网络会话。这个网络会话可以看到哪个域用户来自哪个IP，所以我们一般指定servername为域控或者文件共享服务器。

调用此函数的用户，指定了servername 为机器A，并不需要在机器A 上有管理员权限。所以域内任何用户都可以调用此函数，指定了servername 为域控。

+ 利用`NetWkstaUserEnum`列出当前登录到该机器的所有用户的信息

  一个WIN32 API
  
  ```c++
  NET_API_STATUS NET_API_FUNCTION NetWkstaUserEnum(
    [in]      LMSTR   servername,
    [in]      DWORD   level,
    [out]     LPBYTE  *bufptr,
    [in]      DWORD   prefmaxlen,
    [out]     LPDWORD entriesread,
    [out]     LPDWORD totalentries,
    [in, out] LPDWORD resumehandle
  );
  ```
  
  这个API 的第一个参数servername 可以指定一个远程的机器A，会去调用远程机器A的RPC。然后返回当前登录到机器A的所有用户的信息.值得注意的是，调用该函数的用户需要具备机器A的本地管理员权限。
  
  ![image-20231123212528614](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231123212528614.png)
  
  ![image-20231123215511860](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231123215511860.png)

### 查看域用户登录过的主机

+ 通过查看outlook的邮件头

  当用户a 在公司内部使用outlook 给你发一封邮件的时候，我们可以在改邮件的头部看到用户a的内网IP

  这个没环境就不测了，用一下网上的图

  ![image-20200102185405486](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/t01d6cb7bc49c182ec0.png)

+ 导出DC日志

  要求我们有域控权限，比如说我们在拿到域控之后想找到域内某个用户的主机。

  域内用户A在机器B正常登录的时候，由于本地没有域用户A的hash。机器B会去域控那边做验证，登录成功的话，在域控那边，会有个4624的日志，登录类型为3。

  ![image-20231123220918200](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231123220918200.png)

  值得注意的是，在域内可能存在多台域控，日志并不同步，最好 将每一台域控的日志都导出来。

  利用wevtutil来导出日志，该工具windows自带，用法可自行搜索

  ```shell
  wevtutil epl security C:\1.evtx /q:"*[System[(EventID=4624)] and EventData[Data[@Name='LogonType']='3']]" """
  ```

  将日志拷贝到自己的电脑.使用LogParser开始提取日志

  ```powershell
   .\LogParser.exe -i:EVT -o:CSV "SELECT TO_UPPERCASE(EXTRACT_TOKEN(Strings,5,'|')) as USERNAME,TO_UPPERCASE(EXTRACT_TOKEN(Strings,18,'|')) as SOURCE_IP FROM 1.evtx" >log.csv
  ```

  ![image-20231123223650703](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231123223650703.png)