这一篇主要是对现有的部分漏洞进行复现，以及部分相关细节的补充，之后新的漏洞也就不会补充到这篇里面了

## MS08-068

当用户拿到smb请求之后，最直接的就是把请求relay回本身，即Reflect.从而控制机器本身。

微软在kb957097补丁里面通过修改SMB身份验证答复的验证方式来防止凭据重播，从而解决了该漏洞。

微软所做的措施如下，

主机A向主机B(访问\\B)进行SMB认证的时候，将*pszTargetName*设置为`cifs/B`,然后在type 2拿到主机B发送Challenge之后，在lsass里面缓存(Challenge,`cifs/B`)。

然后主机B在拿到主机A的type 3之后，会去lsass里面有没有缓存(Challenge,`cifs/b`)，如果存在缓存，那么认证失败。

这种情况底下，如果主机B和主机A是不同的主机的话，那lsass里面就不会缓存(Challenge,`cifs/B`)。如果是同一台主机的话，那lsass里面肯定有缓存，这个时候就会认证失败。

这里借用一下图片

![ms08-068](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ntlm/ms08-068.png)

该漏洞利用对win2000 至win2008有效。

漏洞exp可以参看：https://github.com/SecWiki/windows-kernel-exploits/tree/master/MS08-068

## CVE-2015-0005

应用服务器在收到客户端的认证信息时，由于本身没有储存用户的hash，因此会将所有的消息传回域控，这个过程是通过NetLoGon协议完成的.该协议在应用服务器和域服务器之间建立一个安全会话，安全会话共享密钥基于应用服务器主机账号的口令 `NTLM` 生成。

### 漏洞成因

服务端没有用户的hash（注意：服务端并没有去向域控索要用户的hash,而是将所有数据交给域控进行判断），经过认证之后，也就无法算出key_exchange_key，这时认证服务器会像域控索要key_exchange_key.从而计算得出exported_session_key.

漏洞就出在索要key_exchange_key这一阶段，由于域控没有做鉴权，导致只要是机器用户就可以向域控索要key_exchange_key,而第三阶段的key又是能够在流量中明文抓取到的，攻击者就能经过计算得到exported_session_key.

之后的会话就能使用该key进行加解密。

### NETLOGON 步骤

均为 RPC 远程向认证服务器调用

1. NetrLogonSamLoginEx
2. `NetrLogonSamLogonWithFlags`
3. NetrLogonSamLogon
4. NetrLogonSamLogoff

### 漏洞利用

该漏洞的利用在impacket的smbrelayx中已经集成，不需要额外的参数，检测到需要签名会自己调用

如果是非域主机，需要指定当前域内任意一台主机的 hash，且指定域控的 IP。

```python
python smbrelayx.py -h 192.168.30.10 -machine-account hack/PC$ -machine-hashes 2EAE0491D7156EE50ADC9746701F24194E00530055A08072:33649860ee595468 -domain 192.168.30.10 -c hostname
```

这个机器用户的凭据仅是用来向域控申请key_exchange_key作用

## MS16-075(HotPotato)

较早的windows本地提权漏洞，衍生出了很多新的potato

hotptato是基于ntlm_relay来进行的，该漏洞从以下三个方面去思考

+ 发起ntlm请求

  配合NBNS投毒欺骗和伪造WPAD代理服务器拿到用户的net-ntlm hash,所有的HTTP请求将会被重定向至“http://localhost/GETHASHESxxxxx””，其中的xxxxx表示的是某些唯一标识符。将会影响目标主机中所有的用户，包括管理员账户和系统账户。

+ 如何进行relay

  在拿到ntlm之后，虽然MS08-068限制了同台主机smb到smb的relay,但并没有限制http到smb,我们配置配合NBNS投毒欺骗和伪造WPAD代理服务器拿到的ntlm请求说http的形式，我们可以直接relay 到本机的smb。

+ 服务端是否要求签名

  我们Relay到的服务端协议是smb，除非是域内的域控，不然在工作组环节底下，或者域内的域成员机器，都是不要求签名的

来看下漏洞细节

程序首先通过NBNS欺骗，将目标主机的WPAD指向127.0.0.1，然后检查Windows Defender更新。如果目标网络中已经有了WPAD的DNS项，可以使用 -disable_exhaust false 选项，它会导致所有DNS查询失败，从而使用NBNS查询。

获取到ntlm hash之后，进行http->smb的relay

创建一个运行用户定义命令的系统服务，以system权限运行

需要注意的是，win8/10和winserver与win7.win2008之间的部分区别，这影响了我们需要添加的参数

[Potato](https://github.com/foxglovesec/Potato/tree/master)

## CVE-2018-8581

能够访问任意用户的文件。

该漏洞由SSRF漏洞结合NTLM_RELAY可以访问任意用户的邮件，获取域管权限。

![exchange](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ntlm/exchange.png)

+ 发起NTLM请求

  Exchange允许任何用户为推送订阅指定所需的URL，服务器将尝试向这个URL发送通知。问题出在Exchange服务器使用[CredentialCache.DefaultCredentials](https://docs.microsoft.com/en-us/dotnet/api/system.net.credentialcache.defaultcredentials)进行连接。传进的URL我们可控，也就说我们可以控制Exchange服务器向我们发起HTTP 协议的NTLM 请求。我们就能拿到Exchange机器用户的 Net-Ntlm Hash。

  看下微软官方给的例子会比较容易理解

  ```c#
  // Ensure Directory Security settings for default web site in IIS is "Windows Authentication".
  string url = "http://localhost";
  // Create a 'HttpWebRequest' object with the specified url.
  HttpWebRequest myHttpWebRequest = (HttpWebRequest)WebRequest.Create(url);
  // Assign the credentials of the logged in user or the user being impersonated.
  myHttpWebRequest.Credentials = CredentialCache.DefaultCredentials;
  // Send the 'HttpWebRequest' and wait for response.
  HttpWebResponse myHttpWebResponse = (HttpWebResponse)myHttpWebRequest.GetResponse();
  Console.WriteLine("Authentication successful");
  Console.WriteLine("Response received successfully");
  ```

  我们只需要知道该例子向url发送了httprequest

+ 拿到ntlm之后要做什么

  思路1：访问任意用户邮件

  Exchange服务器还默认设置了以下注册表项

  ```
  HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\LsaDisableLoopbackCheck = 1
  ```

  也就是说我们可以将请求Relay 回机器本身。我们拿到的是机器用户的Net-Ntlm Hash。并不能直接用以登录。但是Exchange 机器用户可以获得TokenSerializationRight的"特权"会话，可以Relay 到 机子本身的Ews接口，然后可以使用SOAP请求头来冒充任何用户。

  [脚本链接](https://github.com/WyAtu/CVE-2018-8581)

  思路2：获取域管权限

  获取域管权限主要是利用dcsync进行dump hash后再进行横向移动，要使一个用户具有dcsync权限，只需要如下两条ACL

  ```
  'DS-Replication-Get-Changes'     = 1131f6aa-9c07-11d1-f79f-00c04fc2dcd2
  'DS-Replication-Get-Changes-All' = 1131f6ad-9c07-11d1-f79f-00c04fc2dcd2
  ```

  对于邮件服务器`Exchange Windows Permissions`,`Exchange Trusted Subsystem`都具备Write-ACL的权限。其实`Exchange Trusted Subsystem`是`Exchange Windows Permissions` 组内成员，`Exchange Trusted Subsystem`的成员包括Exchange机器用户。

  我们在拿到Exchange机器的http请求的时候，可以将请求Relay到Ldap,然后由于Exchange机器用户具备Write-ACL权限，我们在域内给添加两条acl，acl的受托人可以是任意用户从而使该用户具备Dcsync的权限。然后dump 域管的hash进行pth，dump kebtgt的hash进行黄金票据。

+ 服务端是否要求签名

  我们需要Relay到的是域控的ldap服务器，对于一个域环境，域控默认开启的签名是smb,ldap一直处于协商签名的模式，也就是说是否需要签名取决于我们的客户端，在exchange服务器上发起的是http请求，而http请求不需要签名。

windows protocol上是通过ntlmralyx+priveexchange来为用户添加这两条ACL并dump hash，事实上可以采取集成化工具，相对会比较方便

![exchange (2)](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ntlm/exchange%20(2).png)

[工具链接](https://github.com/Ridter/Exchange2domain)能够一键利用8581并dump hash

## CVE-2019-1040

当中间人攻击者能够成功绕过 NTLM MIC（消息完整性检查）保护时，Microsoft Windows 中存在篡改漏洞。

+ 如何发起ntlm请求

  之前讲到过利用打印机漏洞进行强制回连，后面觉得不太方便所以换了一个工具，回连变得简单多了。但是基本思路都相同，都通过强制回连来发起ntlm请求。不过拿到的net-ntlm-hash都是机器用户的hash.因此这里有两个思路，一是攻击exchange服务器，一个是直接攻击域管机器

+ 拿到ntlm请求之后要做什么

  上面已经说了，我们拿到的hash是机器用户的hash,并不能直接登录，因此不考虑relay到smb,考虑relay到ldap.显然，relay到ldap，如果我们攻击的是exchange服务器，那么我们就拥有了write acl的权限，能够用已控制的用户去dcsync了，那域管机器呢。

  域管机器用户并不在域管理员组内，权限并不高，但我们可以联系之前提到过的基于资源的约束委派，再来回顾一下，基于资源的约束委派要求我们已经拥有一个服务/机器账户，并且获取服务2的ldap权限，通过设置基于资源的约束委派，我们就能掌控服务2.这里也是一样，我们relay到域控的ldap,并在域管机器MSDS-AllowedToActOnBehalfOfOtherIdentity里面添加一条ace，可以让任何机器用户和服务用户可以控制该用户(NTLM发起者)，虽然不能直接登录，但是因为该机器是域管机器，我们可以进行dcync。

+ 服务端是否要求签名

  不同于8581中以http的形式发起请求，如果通过打印机漏洞发起请求的话是smb协议。我们需要relay到ldap服务器，ldap默认处于协商签名模式，取决于客户端，而smb默认是要求签名的，这也是漏洞的核心，该漏洞绕过了MIC的校验。

  [Wagging-the-Dog](https://shenaniganslabs.io/2019/01/28/Wagging-the-Dog.html)这篇文章介绍的很详细

  最新的绕过将NEGOTIATE_KEY_EXCHANGE和NEGOTIATE_VERSION位置为0，就不再检验MIC了。不像`msvAvFlag`那样参与Reponse的运算，因此置为0之后不仅不会校验mic，也不会使得Reponse校验出错。


### 相关利用

![ntlmrelayx (2)](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ntlm/ntlmrelayx%20(2).png)

![kali](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ntlm/kali.png)

![msds](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ntlm/msds.png)

特别注意：虽然我们指定的攻击目标是10这台机器，实际上relay到的是我们的副域控40,这和relay到主域控没有什么区别

或许你会想尝试一键利用：
[CVE-2019-1040](https://github.com/Ridter/CVE-2019-1040)

很显然这个脚本仅支持邮件服务器存在的情况

## CVE-2019-1384

绕过了MS08-068对lsass缓存的检测，这是因为补丁对lsass缓存中的chanllege是有时效性的，当超过5分钟后，缓存就会被释放，这时就没人管A和B是否是同一台主机，poc通过在315秒之后再relay避免了这个问题

[poc](https://shenaniganslabs.io/files/impacket-ghostpotato.zip)

要求：

用户必须是本地管理员组的成员

用户必须是 Backup Operators 组的成员

令牌必须提升
