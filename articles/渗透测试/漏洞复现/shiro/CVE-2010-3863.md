---
title: CVE-2010-3863
date: 2023-09-03T15:29:52+08:00
updated: 2023-08-08T02:37:16+08:00
categories: 
- 渗透测试
- 漏洞复现
- shiro
---

## 漏洞简介

 Shiro 在对请求路径与 shiro.ini 配置文件配置的 AntPath 进行对比前 未进行路径标准化，导致使用时可能绕过权限校验

## 漏洞复现

影响版本:<1.1.0和JSecurity 0.9.x

直接访问admin界面会302,可以通过添加`./` 访问到管理页面

![2010-3863](E:\笔记软件\笔记\渗透测试\漏洞复现\shiro\2010-3863.png)

## 漏洞分析

由于是初次分析shiro漏洞，我们先来了解一下

`org.apache.shiro.mgt.SecurityManager` 是 shiro 的一个核心接口，接口负责了一个 Subject 也就是“用户”的全部安全操作：

- 接口本身定义了 `createSubject`、`login`、`logout` 三个方法用来创建 Subject、登陆和退出。
- 扩展了 `org.apache.shiro.authc.Authenticator` 接口，提供了 `authenticate` 方法用来进行认证。
- 扩展了 `org.apache.shiro.authz.Authorizer` 接口，提供了对 Permission 和 Role 的校验方法。包括 `has/is/check` 相关命名的方法。
- 扩展了 `org.apache.shiro.session.mgt.SessionManager` 接口，提供了 `start`、`getSession` 方法用来创建可获取会话。

Shiro 为 SecurityManager 提供了一个包含了上述所有功能的默认实现类 `org.apache.shiro.mgt.DefaultSecurityManager`，中间继承了很多中间类，并逐层实现了相关的方法

shiro使用web\src\main\java\org\apache\shiro\web\filter\mgt\PathMatchingFilterChainResolver.java中getChain方法调用filter

```java

    public FilterChain getChain(ServletRequest request, ServletResponse response, FilterChain originalChain) {
        FilterChainManager filterChainManager = getFilterChainManager();
        if (!filterChainManager.hasChains()) {
            return null;
        }

        String requestURI = getPathWithinApplication(request);

        //the 'chain names' in this implementation are actually path patterns defined by the user.  We just use them
        //as the chain name for the FilterChainManager's requirements
        for (String pathPattern : filterChainManager.getChainNames()) {

            // If the path does match, then pass on to the subclass implementation for specific checks:
            if (pathMatches(pathPattern, requestURI)) {
                if (log.isTraceEnabled()) {
                    log.trace("Matched path pattern [" + pathPattern + "] for requestURI [" + requestURI + "].  " +
                            "Utilizing corresponding filter chain...");
                }
                return filterChainManager.proxy(originalChain, pathPattern);
            }
        }

        return null;
    }

```

getPathWithinApplication方法处理url中的path

```java
    public static String getPathWithinApplication(HttpServletRequest request) {
        String contextPath = getContextPath(request);
        String requestUri = getRequestUri(request);
        if (StringUtils.startsWithIgnoreCase(requestUri, contextPath)) {
            // Normal case: URI contains context path.
            String path = requestUri.substring(contextPath.length());
            return (StringUtils.hasText(path) ? path : "/");
        } else {
            // Special case: rather unusual.
            return requestUri;
        }
    }
```

url从第一段代码中就能看出是直接实现的。当url通过一系列操作处理完之后就会使用AntPathMatcher中的domatch方法尝试匹配，若有如下配置

```
[urls]
/user/** = authc
/admin/list = authc, roles[admin]
/admin/** = authc
/audit/** = authc, perms["audit:list"]
/** = anon
```

于是便能在admin前添加`./`使得admin进入/**的范畴，由于为所有其他url设置了anon权限，导致我们可以越权访问

## 漏洞修复

添加了解析url的函数，并且对//,/,./,等进行了单独处理

```java
       if (uri == null) {
            uri = request.getRequestURI();
        }
        return decodeAndCleanUriString(request, uri);
        return normalize(decodeAndCleanUriString(request, uri));
    }

    /**
     * Normalize a relative URI path that may have relative values ("/./",
     * "/../", and so on ) it it.  <strong>WARNING</strong> - This method is
     * useful only for normalizing application-generated paths.  It does not
     * try to perform security checks for malicious input.
     * Normalize operations were was happily taken from org.apache.catalina.util.RequestUtil in
     * Tomcat trunk, r939305
     *
     * @param path Relative path to be normalized
     * 
     */
    private static String normalize(String path) {
        return normalize(path, true);
    }

    /**
     * Normalize a relative URI path that may have relative values ("/./",
     * "/../", and so on ) it it.  <strong>WARNING</strong> - This method is
     * useful only for normalizing application-generated paths.  It does not
     * try to perform security checks for malicious input.
     * Normalize operations were was happily taken from org.apache.catalina.util.RequestUtil in
     * Tomcat trunk, r939305
     *
     * @param path Relative path to be normalized
     * @param replaceBackSlash Should '\\' be replaced with '/'
     */
    private static String normalize(String path, boolean replaceBackSlash) {

        if (path == null)
            return null;

        // Create a place for the normalized path
        String normalized = path;

        if (replaceBackSlash && normalized.indexOf('\\') >= 0)
            normalized = normalized.replace('\\', '/');

        if (normalized.equals("/."))
            return "/";

        // Add a leading "/" if necessary
        if (!normalized.startsWith("/"))
            normalized = "/" + normalized;

        // Resolve occurrences of "//" in the normalized path
        while (true) {
            int index = normalized.indexOf("//");
            if (index < 0)
                break;
            normalized = normalized.substring(0, index) +
                normalized.substring(index + 1);
        }

        // Resolve occurrences of "/./" in the normalized path
        while (true) {
            int index = normalized.indexOf("/./");
            if (index < 0)
                break;
            normalized = normalized.substring(0, index) +
                normalized.substring(index + 2);
        }

        // Resolve occurrences of "/../" in the normalized path
        while (true) {
            int index = normalized.indexOf("/../");
            if (index < 0)
                break;
            if (index == 0)
                return (null);  // Trying to go outside our context
            int index2 = normalized.lastIndexOf('/', index - 1);
            normalized = normalized.substring(0, index2) +
                normalized.substring(index + 3);
        }

        // Return the normalized path that we have completed
        return (normalized);

    }

```

